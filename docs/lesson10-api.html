<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/kotlin.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/vs.css">
</head>
<body>
<div class="reveal">
	<div class="slides">
		<section data-background-gradient="var(--kotlin-gradient)">
			<i>Week 2 | Lesson 10</i>
			<h1>Application Programming Interface</h1>
			<em>REST API</em><br />
			<em>Reflection</em>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>What is API</h2>
			</section>
			<section>
				<h3>What is API</h3>
				<div class="summary">
					API stands for <strong>Application Programming Interface</strong>.
				</div>
				<div class="content">
					<ul>
						<li>
							It is a set of rules and protocols that allow different software applications to communicate with each other.
						</li>
						<li>
							In contrast to user interface, API is meant for program to program or computer to computer communication.
						</li>
						<li>
							There are many forms of APIs, such as web APIs, library APIs, and operating system APIs.
							Some APIs are specific to a particular programming language, some are specific to a particular application.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Design of API</h3>
				<div class="content">
					<blockquote>
						When you think about designing an interface, you first need to think about the problem you are trying to solve with it.
						Consider how the API will be used, and design it in a way that is convenient for the users of the API.
					</blockquote>
					<p>
						This is why in this course, we will start by designing and interface (API) and only then we will implement the service and data model behind it.
					</p>
					<p>
						If we did it the other way around, we would be tempted to design the service and data model in a way that is convenient for us, the developers, and not in a way that is convenient for the users of the API.
					</p>
				</div>

			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>What is REST</h2>
			</section>
			<section>
				<h3>What is REST</h3>
				<div class="summary">
					REST stands for <string>Representational State Transfer</string>.
				</div>
				<div class="content">
					<blockquote>
						It is an architectural style for designing networked applications.
						Systems that follow REST principles are often called RESTful systems.
						Characteristics of RESTful systems include <strong>statelessness</strong>,
						<strong>client-server architecture</strong>, and a <strong>uniform interface</strong>.
					</blockquote>
					<ul>
						<li>
							<strong class="highlight">Statelessness</strong><br />
							Each request from a client to a server must contain all of the information
							necessary process the request, without relying on any server state being held between requests.
						</li>
						<li>
							<strong class="highlight">Client-server architecture</strong><br />
							The client and server are separate and independent of each other, only communicating by well-defined requests and responses.
							This allows each to be developed and scaled independently.
							<br />
							<br />
							In real applications, client is usually responsible for the user interactions and the server is responsible for the data storage and processing.
						</li>
						<li>
							<strong class="highlight">Uniform interface</strong><br />
							The API should be designed in a way that is consistent, predictable,
							handles errors gracefully, is platform-agnostic, and is easy to understand and use.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>REST API</h3>
				<div class="summary">
					Communication through REST API is done using standard HTTP methods,
					such as <strong>GET</strong>, <strong>POST</strong>, <strong>PUT</strong>, and <strong>DELETE</strong>.
				</div>
				<div class="content">
					<p>
						REST communication is <strong>request-response</strong> protocol,
						which means that the client sends a request to the server, and the server sends a response back to the client.
					</p>
					<p>
						Each request is sent to a unique URI (Uniform Resource Identifier),
						which represents a <strong>resource</strong> on the server.
					</p>
					<p>
						The server processes the request and sends back a response, which may include data, status,
						and other information, usually in JSON or XML format.
					</p>
				</div>
			</section>
			<section>
				<h3>Request</h3>
				<div class="content">
					<ul>
						<li>
							<strong>HTTP Method</strong><br />
							<em>Defines the type of action to be performed on the resource.</em>
							<br />
							<code class="inline">
								GET /accounts
							</code>
						</li>
						<li>
							<strong>URI</strong><br />
							<em>
								Identifies a unique <strong>resource</strong> on the server.
								It is usually composed of <strong>path</strong> and optionally <strong>query parameters</strong>.
							</em>
							<br />
							<code class="inline">
								GET /accounts/123/users?limit=10&search=joe
							</code>
						</li>
						<li>
							<strong>Headers</strong><br />
							<em>
								These can be used to send additional data with the request, such as the content type or an authorization token.
							</em>
							<br />
							<code class="inline">Content-Type: application/json</code><br />
							<code class="inline">Authorization: Bearer some-token-value</code>
						</li>
						<li>
							<strong>Body</strong><br />
							<em>
								Body is usually sent only with <strong>POST</strong>, <strong>PUT</strong> and <strong>PATCH</strong> requests.
								In most cases, this will be formatted as JSON or XML.
							</em>
							<br />
							<code class="inline">
								{ "username": "testUser", "password" : "123456" }
							</code>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Response</h3>
				<div class="content">
					<ul>
						<li>
							<strong>HTTP Status Code</strong><br />
							A numerical code that indicates the success or failure of the request.
							There is a convention for what status code should be used in what situation.
						</li>
						<li>
							<strong>Headers</strong><br />
							As in the request, headers in the response can be used to pass additional information. This might include the content type of the response, or a Set-Cookie header to store information in the client's browser.
						</li>
						<li>
							<strong>Body</strong><br />
							This contains the actual data being returned from the server.
							This will usually be in JSON or XML format, or could also be plain text.
							<br />
							<code class="inline">
								{ "id": 1, "username": "testUser", "email": "testUser@example.com" }
							</code>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Methods</h3>
				<div class="summary">
					In theory, you can use all methods of HTTP protocol to communicate with REST API.
				</div>
				<div class="content">
					<p>
						In practice, you will mostly use ...
					</p>
					<ul>
						<li>
							<strong>GET</strong><br />
							Used to retrieve data from the server. It should never change the state of the server.
						</li>
						<li>
							<strong>POST</strong><br />
							Used to send data to the server to create a new resource.
						</li>
						<li>
							<strong>PUT</strong><br />
							<em>
								Used to send data to the server to update an existing resource.
								Changes should be idempotent, meaning that if you send the same request multiple times,
								the result should be the same as if you sent it once.
								In other words, PUT should be used to update the resource as a whole.
							</em>
						</li>
						<li>
							<strong>DELETE</strong><br />
							Used to delete a resource from the server.
						</li>
						<li>
							<strong>PATCH</strong><br />
							Used to partially update a resource on the server.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Paths</h3>
				<div class="summary">
					URI is the path to the resource on the server.
				</div>
				<div class="content">
					<p>
						You can use <strong>path parameters</strong> to specify a particular resource,
						and <strong>query parameters</strong> to, for example, filter or paginate the results.
					</p>
					<p>
						Here is the conventional structure of the resource:
						<br />
						<br />
						<code style="color: steelblue">/resources/</code>
						<code style="color: magenta">{path-parameter}</code>
						<code style="color: steelblue">/sub-resource</code>
						<code style="color: red">?</code>
						<code style="color: green">param1=value</code>
						<code style="color: orange">&</code>
						<code style="color: green">param2=value</code>
					</p>
					<ul>
						<li><span style="color: steelblue">resource path</span></li>
						<li><span style="color: magenta">path parameter</span></li>
						<li><span style="color: red">path and query parameter separator</span> </li>
						<li><span style="color: orange">query parameter separator</span></li>
						<li><span style="color: green">query parameters </span> and their values</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Headers</h3>
				<div class="summary">
					Headers are used to pass additional information with the request or response.
				</div>
				<div class="content">
					<p>
						Headers are usually conventional, meaning that there are some standard headers that are used in most APIs.
						REST services can also define their own custom headers.
					</p>
					<p>Some of the most common conventional headers are:</p>
					<ul>
						<li>
							<strong>Content-Type</strong><br />
							Used to specify the format of the body of the request.<br />
							<code class="inline">Content-Type: application/json</code>
						</li>
						<li>
							<strong>Accept</strong><br />
							Used to specify the format of the response.<br />
							<code class="inline">Accept: application/json</code>
						</li>
						<li>
							<strong>Authorization</strong><br />
							Used to pass an authorization token with the request.<br />
							<code class="inline">Authorization: Bearer some-token-value</code>
						</li>
						<li>
							<strong>X-Api-Key</strong><br />
							Used to pass an API key with the request.<br />
							<code class="inline">X-Api-Key: some-api-key-value</code>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Body</h3>
				<div class="summary">
					Body is usually sent only with <strong>POST</strong>, <strong>PUT</strong> and <strong>PATCH</strong> requests.
				</div>
				<div class="content">
					<p>
						Body is almost exclusively custom, meaning that it is up to the service to define what the body of the request or response should look like.
					</p>
					<p>
						Most common formats for the body are JSON and XML.
					</p>
					<p>
						JSON:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs json">
							{
								"id": 1234,
								"firstName": "Monika",
								"lastname": "Protivova",
								"email": "monika.protivova@gmail.com",
								"isAdmin": true
							}
						</code>
					</pre>
					<p>
						XML:
					</p>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs xml">
							&lt;user&gt;
								&lt;id&gt;1234&lt;/id&gt;
								&lt;firstName&gt;Monika&lt;/firstName&gt;
								&lt;lastname&gt;Protivova&lt;/lastname&gt;
								&lt;email&gt;monika.protivova@gmail.com&lt;/email&gt;
								&lt;isAdmin&gt;true&lt;/isAdmin&gt;
							&lt;/user&gt;
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Status Codes</h3>
				<div class="summary">
					HTTPS status codes are used to indicate the success or failure of the request.
				</div>
				<div class="content">
					<div class="row">
						<div class="column">
							<ul>
								<li>
									<strong>1xx</strong><br />
									Informational responses. The request was received, continuing process.
									<ul>
										<li>100 - Continue</li>
										<li>101 - Switching Protocols</li>
									</ul>
								</li>
								<li>
									<strong>2xx</strong><br />
									Success. The action was successfully received, understood, and accepted.
									<ul>
										<li>200 - OK</li>
										<li>201 - Created</li>
									</ul>
								</li>
								<li>
									<strong>3xx</strong><br />
									Redirection. Further action must be taken in order to complete the request.
									<ul>
										<li>301 - Moved Permanently</li>
									</ul>
								</li>
							</ul>
						</div>
						<div class="column">
							<ul>
								<li>
									<strong>4xx</strong><br />
									Client Error. The request contains bad syntax or cannot be fulfilled.
									<ul>
										<li>400 - Bad Request</li>
										<li>401 - Unauthorized</li>
										<li>403 - Forbidden</li>
										<li>404 - Not Found</li>
									</ul>
								</li>
								<li>
									<strong>5xx</strong><br />
									Server Error. The server failed to fulfill an apparently valid request.
									<ul>
										<li>500 - Internal Server Error</li>
									</ul>
								</li>
							</ul>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>REST API design practices</h3>
				<div class="summary">
					When designing a REST API, it is important to follow some good practices.
				</div>
				<div class="content">
					<br />
					<h4>Naming conventions</h4>
					<ul>
						<li>Paths should be nouns and should be plural.</li>
						<li>Paths should represent hierarchical relationships.</li>
						<li>Paths should preferably be lowercase, and not case-sensitive.</li>
						<li>Query parameters should be named in consistent matter, either using
							<ul>
								<li>camelCase</li>
								<li>snake_case</li>
								<li>kebab-case</li>
								<li> ... but not combining them</li>
							</ul>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>REST API design practices</h3>
				<div class="summary">
					When designing a REST API, it is important to follow some good practices.
				</div>
				<div class="content">
					<br />
					<h4>Versioning</h4>
					<ul>
						<li>Once you publish a (public) API, you may not be able to control who uses it.</li>
						<li>API versioning is thus important to ensure that any changes are backward compatible.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>REST API design practices</h3>
				<div class="summary">
					When designing a REST API, it is important to follow some good practices.
				</div>
				<div class="content">
					<br />
					<h4>Request and response format</h4>
					<ul>
						<li>API should return data in a consistent format, such as JSON or XML.</li>
						<li>Naming conventions should be consistent, for example, use <code class="inline">camelCase</code> or <code class="inline">snake_case</code> consistently throughout the API.</li>
						<li>For services written in Java, it is more nature to use <code class="inline">camelCase</code>, because it matches class field naming conventions.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>REST API design practices</h3>
				<div class="summary">
					When designing a REST API, it is important to follow some good practices.
				</div>
				<div class="content">
					<br />
					<h4>Response codes and error handling</h4>
					<ul>
						<li>Each method should respond with appropriate status code.</li>
						<li>For example:
							<ul>
								<li>successful requests that do not modify resource should be either 200 or 204</li>
								<li>successful requests that create a new resource should be 201</li>
								<li>requests that fail due to user error should return 4xx</li>
								<li>requests that fail due to user input error should fail with 400</li>
								<li>requests tha fail due to authentication error should fail with 401</li>
								<li>requests that fail due to authorization error should fail with 403</li>
								<li>requests that fail due to resource not found should fail with 404</li>
								<li>requests that fail due to server error should return 5xx</li>
							</ul>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>REST API design practices</h3>
				<div class="summary">
					When designing a REST API, it is important to follow some good practices.
				</div>
				<div class="content">
					<br />
					<h4>Overall consistency</h4>
					<ul>
						<li>API should be consistent in its design and behavior.</li>
						<li>For example, if POST method for one resource returns the newly created object, then POST method for another resource should also return the newly created object.</li>
					</ul>
				</div>
			</section>
		</section>

		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Reflection</h2>
			</section>
			<section>
				<h3>Reflection</h3>
				<div class="summary">
					Reflection allows us to inspect and modify runtime behavior of classes, interfaces, fields, and methods at runtime, without knowing their name at compile time.
				</div>
				<div class="content">
					<p>
						Reflection is part of the Kotlin API, and is defined in the <code class="inline">kotlin.reflect</code> package.
					</p>
					<p>
						Reflection is used by many frameworks, such as Spring, Jackson, Hibernate, and JUnit.
					</p>
					<p>
						<strong>Reflection allows us to:</strong>
					<ul>
						<li>Inspect classes</li>
						<li>Inspect constructors</li>
						<li>Inspect methods</li>
						<li>Inspect fields</li>
						<li>Instantiate objects dynamically</li>
						<li>Invoke methods</li>
						<li>Get or set field value</li>
						<li>Change field value</li>
					</ul>
					</p>
				</div>
			</section>
			<section>
				<h3>Reflection</h3>
				<div class="content">
					Given class ...
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							package lesson10

							class Employee(
								val id: Long,
								private var firstName: String,
								private var lastName: String,
								private var position: String
							) {

								fun getEmployee(): String = "$firstName $lastName: $position"

								fun updateEmployee(firstName: String, lastName: String, position: String) {
									this.firstName = firstName
									this.lastName = lastName
									this.position = position
								}
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Reflection</h3>
				<div class="content">
					Inspection of classes, constructors, methods and fields.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							package lesson10;

							fun main() {
								val obj = Employee(
									id = 123,
									firstName = "Monika",
									lastName = "Protivova",
									position = "Kotlin Developer"
								)

								val cls = obj.javaClass

								// Inspect class
								println("Class: ")
								println(" Name = ${cls.name}")
								println(" Simple Name = ${cls.simpleName}")
								println(" Package = ${cls.`package`}")
								println(" Superclass = ${cls.superclass}")
								println(" Interfaces = ${cls.interfaces.contentToString()}")

								// Inspect constructors
								val constructors = cls.constructors
								println("Constructors: ")
								for (constructor in constructors) {
									println(" Parameters = ${constructor.parameterTypes.contentToString()}")
								}

								// Inspect methods
								val methods = cls.methods
								println("Methods: ")
								for (method in methods) {
									println(" Method = ${method.name}")
									println(" Parameters = ${method.parameterTypes.contentToString()}")
								}

								// Inspect fields
								val fields = obj.javaClass.declaredFields
								println("Fields: ")
								for (field in fields) {
									println(" Field = ${field.name}")
									println(" Type = ${field.annotatedType}")
								}
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Reflection</h3>
				<div class="content">
					Instantiation, dynamic invocation of methods and fields, and changing field values.
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							package lesson10;

							import java.time.LocalDate

							fun main() {
								try {
									// get class by fully qualified name
									val cls = Class.forName("lesson10.Employee")

									// create instance
									val instance = cls
										.getDeclaredConstructor(Long::class.java, String::class.java, String::class.java, String::class.java)
										.newInstance(123, "Monika", "Protivova", "Developer")

									// get method
									val getterMethod = cls.getDeclaredMethod("getEmployee")

									// invoke the method on existing instance
									val getterValue = getterMethod.invoke(instance)

									// should print Java
									println(getterValue)

									val setterMethod = cls.getDeclaredMethod("updateEmployee", String::class.java, String::class.java, String::class.java)
									val noReturnValue = setterMethod.invoke(instance, "Monika", "Protivova", "Kotlin Developer")

									// should print null
									println(noReturnValue)

									// should print Python
									println(getterMethod.invoke(instance))

								} catch (e: Exception) {
									// reflection may throw multiple types of exceptions
									println("Error: ${e.message}")
								}
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h4>Reflection use cases</h4>
				<div class="summary">
					Reflection is often used by frameworks and libraries to provide functionality that would be difficult to achieve otherwise,
					such as runtime configuration, serialization, and deserialization, type analysis, object instantiation, and method invocation.
				</div>
				<div class="content">
					<div>
						<h4>Frameworks</h4>
						<p>
							Java/Kotlin frameworks use reflection to analyze and manipulate the classes, interfaces, constructors, methods, and fields that they work with.
							For instance, Spring Framework uses it to create classes via IoC, Hibernate uses reflection API to fetch data and populate your entity objects.
						</p>
					</div>
					<br />
					<div>
						<h4>Testing</h4>
						<p>
							Tools like JUnit and Mockito use the reflection to observe class, field, and method size, and also to call methods while doing the testing.
						</p>
					</div>
					<br />
					<div>
						<h4>Serialization & Deserialization</h4>
						<p>
							Reflection is often used to convert (text) data, such as JSON, to an equivalent Java objects and vice versa.
						</p>
					</div>
				</div>
			</section>
			<section>
				<h4>Reflection pitfalls</h4>
				<div class="summary">
					Despite its usefulness, it is not recommended to use reflection where not necessary because of the following reasons.
				</div>
				<div class="content" style="font-size: 70%">
					<div>
						<h4>Performance Overhead</h4>
						<p>
							Reflection operations have performance overhead because it involves type inference, and often disables certain JVM optimizations.
							Reflective code is therefore generally slower than the normal code, and should be avoided in parst of the code that are called frequently,
							or in performance-critical applications.
						</p>
					</div>
					<div>
						<h4>Exposure of Internals</h4>
						<p>
							Reflections allows access to restricted parts of the code, such as private methods and fields.
							By doing this, it breaks the encapsulation and exposes the internals of the class in a way it was not designed to be used.
						</p>
					</div>
					<div>
						<h4>Lack of Compile-Time Safety</h4>
						<p>
							Reflection bypasses the compile-time type checks, and therefore may result in runtime exceptions.
						</p>
					</div>
					<div>
						<h4>Decreased Maintainability of Code</h4>
						<p>
							Reflection makes the code less readable and maintainable, by making it more difficult to understand.
							It also makes the code more error-prone, because the compiler cannot detect errors in the reflective code.
						</p>
						<p>
							Additionally, it makes a lot of development tools, such as IDEs, less useful, because they cannot analyze the reflective code.
						</p>
					</div>
					<div>
						<h4>Security Concerns</h4>
						<p>
							Reflection can access and manipulate private fields and methods, which can be a security concern.
						</p>
					</div>
				</div>
			</section>
		</section>

		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Practice</h2>
			</section>
		</section>

	</div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	});
</script>
</body>
</html>
