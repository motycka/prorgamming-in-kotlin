<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="./dist/reset.css">
	<link rel="stylesheet" href="./dist/reveal.css">
	<link rel="stylesheet" href="./dist/theme/kotlin.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="./plugin/highlight/vs.css">
</head>
<body>
<div class="reveal" >
	<div class="slides">
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<i>Week 1 | Lesson 1</i>
				<h1>Introduction to Kotlin</h1>
				<em>Java and Kotlin</em><br />
				<em>History, Syntax, Types, Operators, Conditionals</em>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Introduction to <del>Kotlin</del> Java</h2>
			</section>
			<section>
				<h3>Brief history of Java</h3>
				<div class="summary">
					Why do we need to talk about Java first?
				</div>
				<div class="content" style="text-align: center">
					<p>
						While Java and Kotlin are two separate languages, they are closely related.
						They both run on the Java Virtual Machine (JVM), and they are interoperable.
						In fact, Kotlin compiles to Java bytecode, which means that it can run on any platform that supports Java.
						Understanding some basic principles in Java will help you understand Kotlin better.
					</p>
					<br />
					<img src="./img/java.png" alt="Java Logo" style="width: 200px"/>
					<img src="./img/to-right.png" style="height: 40px; padding: 40px"/>
					<img src="./img/Kotlin_logo_2021.svg" alt="Kotlin Logo" style="width: 200px; padding-bottom: 40px; padding-top: 40px"/>
				</div>
			</section>
			<section>
				<h3>Brief history of Java</h3>
				<div class="content" style="text-align: center">
					<ul style="text-align: left">
						<li>Developed by Sun Microsystems</li>
						<li>Introduced in 1995</li>
						<li>First version available in 1996</li>
						<li>Open source since 2007</li>
						<li>Sun Microsystems was acquired by Oracle in 2010</li>
					</ul>
					<div>
						<img src="./img/java.png" alt="Java Logo" style="width: 200px"/>
						<img src="./img/to-right.png" style="height: 40px; padding: 40px"/>
						<img src="./img/Kotlin_logo_2021.svg" alt="Kotlin Logo" style="width: 200px; padding-bottom: 40px; padding-top: 40px"/>
					</div>
				</div>
			</section>
			<section>
				<h3>Key features of Java</h3>
				<div class="content">
					<p>
						<b>Simple</b><br/>
						<i style="font-size: 80%">easy to learn and use, familiar syntax (based on C++), memory management</i>
					</p>
					<p>
						<b>Object-Oriented</b><br/>
						<i style="font-size: 80%">everything in Java is an object</i>
					</p>
					<p>
						<b>Platform Independent, Portable, Architecture-Neutral</b><br/>
						<i style="font-size: 80%">write once, run anywhere (on java virtual machine), compiled to Java byte code, no specific architecture dependent features (for example data types)</i>
					</p>
					<p>
						<b>Multi-Threaded</b><br/>
						<i style="font-size: 80%">enables concurrent task execution</i>
					</p>
					<p>
						<b>Secure</b><br/>
						<i style="font-size: 80%">no pointers, runs inside virtual machine, guards against illegal access to resources</i>
					</p>
					<p>
						<b>Robust</b><br/>
						<i style="font-size: 80%">no pointers, memory management, strong type checking</i>
					</p>
					<p>
						<b>High Performance</b><br/>
						<i style="font-size: 80%">slower than compiled languages, but fast for interpreted language due java byte code being close to native code</i>
					</p>
				</div>
			</section>
			<section>
				<h3>Java has two main components ...</h3>
				<div class="content content-center">
					<h4>Java Runtime Environment (JRE)</h4>
					<p>
						The JRE provides the libraries, the Java Virtual Machine (JVM),
						and other components needed to run applications written in Java.
						It does not include developer tools such as compilers and debuggers.
					</p>
					<p>
						<em>As a user, you would use the JRE to run Java programs on your system.</em>
					</p>
				</div>
				<div class="content content-center">
					<h4>Java Development Kit (JDK)</h4>
					<p>
						The JDK includes the JRE as well as a set of development tools for writing and running Java programs.
						These tools include the Java compiler (javac), an archiver (jar), a documentation generator (javadoc),
						and other tools needed in Java development.
					</p>
					<p>
						<em>As a programmer, you would use the JDK to develop Java applications.</em>
					</p>
				</div>
			</section>
			<section>
				<h3>Java Development Kit (JDK)</h3>
				<div class="summary">
					Since open sourcing, multiple implementations of JDK exist ...
				</div>
				<div class="content">
					<p>
						<strong>Oracle JDK</strong><br />
						<em style="font-size: 80%">widely used, but need to purchase license for commercial use</em>
					</p>
					<p>
						<strong>OpenJDK</strong><br />
						<em style="font-size: 80%">open-source, Oracle JDK's source code is based on this, and it's free to use</em>
					</p>
					<p>
						<strong>Amazon Corretto</strong><br />
						<em style="font-size: 80%">free, active support, performance enhancements, security fixes</em>
					</p>
					<p>
						<strong>AdoptOpenJDK/Adoptium</strong><br />
						<em style="font-size: 80%">community-led</em>
					</p>
					<p>
						<strong>Azul Zulu OpenJDK</strong><br />
						<em style="font-size: 80%">free to use</em>
					</p>
					<p>
						<strong>IBM OpenJ9</strong><br />
						<em style="font-size: 80%">open-source, optimized for small memory footprint, fast startup, and high throughput</em>
					</p>
				</div>
				<aside class="notes">
					<b>Oracle JDK:</b> Oracle provides a JDK implementation that is probably the most widely used. It is commercial, and you would need to purchase a license to use it on commercial projects.
					<b>OpenJDK:</b> OpenJDK is the open-source implementation of the Java SE Platform. Oracle JDK's source code is based on this, and it's free to use.
					<b>Amazon Corretto:</b> Amazon provides this no-cost distribution of OpenJDK. It comes with long-term support that includes performance enhancements and security fixes.
					<b>AdoptOpenJDK/Adoptium:</b> AdoptOpenJDK is a community-led initiative that provides pre-built OpenJDK binaries. It has been shifted to a new project Adoptium now.
					<b>Azul Zulu OpenJDK:</b> Azul provides Zulu, which is a certified build of OpenJDK and is free to use.
					<b>IBM OpenJ9:</b> OpenJ9 is an open-source JVM from IBM, optimized for small memory footprint, fast startup, and high throughput.
				</aside>
			</section>
			<section>
				<h3>Java Releases: Major Versions</h3>
				<div class="content content-center">
					<div class="row">
						<div class="column">
							<ul>
								<li>1990s - project start</li>
								<li>1995 - officially named Java</li>
								<li>1996 - Java Development Kit (JDK) 1.0</li>
								<li>1997 - JDK 1.1</li>
								<li>1998 - J2SE 1.2</li>
								<li>2000 - J2SE 1.3</li>
								<li>2002 - J2SE 1.4</li>
								<li>2004 - J2SE 5.0</li>
							</ul>
						</div>
						<div class="column">
							<ul>
								<li>2006 - Java SE 6</li>
								<li>2011 - Java SE 7</li>
								<li>2014 - Java SE 8</li>
								<li>2017 - Java SE 9</li>
								<li>2018 - Java SE 10, 11</li>
								<li>2019 - Java SE 12, 13</li>
								<li>2020 - Java SE 14, 15</li>
								<li>2021 - Java SE 16, 17, 18</li>
								<li>2022 - Java SE 19</li>
							</ul>
						</div>
					</div>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Introduction to Kotlin</h2>
			</section>
			<section>
				<h3>What is Kotlin?</h3>
				<div class="content content-center content-100">
					<ul>
						<li>
							Developed by <a href="https://www.jetbrains.com/">JetBrains</a> and officially released in 2016.
						</li>
						<li>
							Statically-typed programming language that runs on the Java Virtual Machine (JVM).
						</li>
						<li>
							Fully interoperable with Java, which means that you can use Java libraries in Kotlin and vice versa.
						</li>
						<li>
							Designed to improve on Java's shortcomings, and it is considered a modern alternative to Java.
						</li>
						<li>
							It has modern and intuitive syntax, and it is designed to be concise and expressive.
						</li>
					</ul>
					<img src="https://resources.jetbrains.com/storage/products/company/brand/logos/jetbrains.png" alt="JetBrains Logo" style="width: 200px"/>
				</div>
			</section>
			<section>
				<h3>Important features</h3>
				<div class="content">
					<ul>
						<li>
							<strong class="highlight">Null safety</strong>
							<span>by distinguishing nullable and non-nullable types</span>
						</li>
						<li>
							<strong class="highlight">Interoperability</strong>
							<span>with Java, allowing developers to use Java libraries in Kotlin and vice versa</span>
						</li>
						<li>
							<strong class="highlight">Conciseness</strong>
							<span>reducing boilerplate code and improving readability</span>
						</li>
						<li>
							<strong class="highlight">Coroutines</strong>
							<span>provide built-in support for coroutines for easy and efficient concurrent programming</span>
						</li>
						<li>
							<strong class="highlight">Extension Functions</strong>
							<span>allowing you to add new functions to existing classes without modifying their source code</span>
						</li>
						<li>
							<strong class="highlight">Data Classes</strong>
							<span>providing a concise way to create classes that only hold data</span>
						</li>
						<li>
							<strong class="highlight">Higher-Order Functions and Lambdas</strong>
							<span>supporting functional programming paradigms</span>
						</li>
						<li>
							<strong class="highlight">Companion Objects</strong>
							<span>providing a way to create static methods and properties in Kotlin</span>
						</li>
						<li>
							<strong class="highlight">Smart Casts</strong>
							<span>used to automatically casts types when certain conditions are met</span>
						</li>
						<li>
							<strong class="highlight">Sealed Classes</strong>
							<span>providing a way to restrict inheritance</span>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Kotlin Releases: Major Versions</h3>
				<div class="content" style="font-size: 70%">
					<ul>
						<li><strong>2010:</strong> Project Kotlin was born. JetBrains unveiled Project Kotlin, a new language for the JVM, which had been under development for a year.</li>
						<li><strong>2012:</strong> JetBrains open sourced Project Kotlin. The company has set up a Web demo for the language, and a plugin is already available for IntelliJ IDEA 11.</li>
						<li><strong>2016:</strong> Kotlin 1.0 was officially released. It was considered stable and ready for production.</li>
						<li><strong>2017:</strong> Google officially announced Kotlin as a first-class language for Android applications development during Google I/O. This played a crucial role in Kotlin's popularity among Android developers.</li>
						<li><strong>2019:</strong> Google announced Kotlin as its preferred language for Android app developers, meaning that development tooling would be optimized for Kotlin, and that Kotlin-specific APIs would be prioritized.</li>
						<li><strong>2020:</strong> Kotlin 1.4 released with focusing on improving the performance and tooling.</li>
						<li><strong>2021:</strong> Release of Kotlin 1.5.0 with stable language features like JVM records, sealed interfaces and the new default JVM IR compiler.</li>
						<li><strong>2022:</strong> Kotlin 1.6 was released in November 2021.</li>
						<li><strong>2023:</strong> Kotlin 1.7 was released in June 2023, including the alpha version of the new Kotlin K2 compiler.</li>
						<li><strong>2023:</strong> Kotlin 1.8 was released in December 2023, 1.8.0 was released on January 11, 2024.</li>
						<li><strong>2024:</strong> Kotlin 1.9 was released in July 2024, 1.9.0 was released on July 6, 2024.</li>
						<li><strong>2024:</strong> Kotlin 2.0 was released in May 2024, 2.0.0 was released on May 21, 2024.</li>
					</ul>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Kotlin and other languages</h2>
				<i>Where does it stand compared to other languages?</i>
			</section>
			<section>
				<h3>Use right tools for the job</h3>
				<div class="summary">
					“If the only tool you have is a hammer, you tend to see every problem as a nail.”
					<br />
					~ Abraham Maslow
				</div>
				<div class="content content-center">
					<img src="./img/hammer.jpg" alt="Hammer" style="width: 600px"/>
				</div>
			</section>
			<section>
				<h3>C/C++ </h3>
				<div class="summary">
					The C/C++ family of languages is known for its high-performance capabilities,
					offering programmers a high level of control over system resources.
				</div>
				<div class="content">
					<ul>
						<li>They are best suited for tasks where efficiency, performance, or precise control is paramount.</li>
						<li>More complicated syntax and lack of modern language conveniences can make them more challenging to master.</li>
						<li>Developers must handle memory management manually, which can introduce errors, vulnerabilities, and security risks.</li>
						<li>Implementing high-level, complex business requirements may require a considerable amount of skill and lines of code.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Python</h3>
				<div class="summary">
					Python is a powerful and flexible, well suited for working with data or scripting.
				</div>
				<div class="content">
					<ul>
						<li>Python has simple and readable syntax, making it accessible to beginners</li>
						<li>
							It's an interpreted language, which can make it slightly slower than Java in certain scenarios.
							<em style="font-size: 80%">However, scientific computation libraries like NumPy and SciPy leverage C for enhanced performance.</em>
						</li>
						<li>Due to its extensive libraries, Python is widely favored among the data science community.</li>
						<li>Python's flexibility may introduce security and type-safety concerns during runtime</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>JavaScript / TypeScript</h3>
				<div class="summary">
					JavaScript and TypeScript are widely used for front-end web development, enabling interactive web applications.
					Additionally, server-side JavaScript and TypeScript, powered by Node.js, have gained popularity.
				</div>
				<div class="content">
					<ul>
						<li>Easy to learn, fast to develop, and flexible.</li>
						<li>Large community with abundant frameworks and tools.</li>
						<li>However, they can be relatively inefficient as it is interpreted language and by design runs in a single thread.</li>
						<li>Vanilla JavaScript lacks type safety and robustness, potentially compromising overall safety.</li>
						<li>Not ideal for high-availability or critical systems.</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Java</h3>
				<div class="summary">
					Java offers a balanced mix of efficiency, power, flexibility, and safety.
				</div>
				<div class="content">
					<ul style="font-size: 90%">
						<li>Not as efficient as C/C++, but generally performs really well</li>
						<li>Not as flexible as Python/JavaScript/TypeScript, but flexible enough</li>
						<li>Larger memory footprint than Python, but its robust safety features compensate for this</li>
						<li>Java is mostly used for:
							<ul>
								<li>Web Applications - <em>mostly the application backend</em></li>
								<li>Mobile Applications - <em>Android, although it is being replaced by Kotlin</em></li>
								<li>Enterprise Applications - <em>Java EE, banking and finance systems, healthcare systems, etc.</em></li>
								<li>Cloud-based Applications - <em>serverless applications, cloud functions</em></li>
								<li>Scientific Applications & Big Data - <em>AI and ML applications, Apache Spark, etc.</em></li>
								<li>Gaming - <em>mostly on Android (What popular game is in Java?)</em></li>
								<li>IoT & Embedded Systems - <em>IoT, embedded systems, smart devices</em></li>
								<li>Middleware - <em>such as web servers, WebSphere, Tomcat, ...</em></li>
								<li>Desktop GUI Applications - <em>JavFX, Swing</em></li>
							</ul>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>C#</h3>
				<div class="summary">
					C# is often regarded as one of Java's major competitors.
					While they share many similarities in terms of usage and capabilities, there are key differences.
				</div>
				<div class="content">
					<ul style="font-size: 80%">
						<li>They are pretty similar in terms of usage and capabilities</li>
						<li>
							Java was initially intended for cross-platform compatibility through the Java Virtual Machine (JVM),
							adhering to the "Write Once, Run Anywhere" principle.
						</li>
						<li>In contrast, C# was originally developed for Windows development within the .NET framework.</li>
						<li>Today, C# has expanded its reach to different platforms through .NET Core.</li>
						<li>Both languages are rooted in the syntax of C/C++, but C# offers more syntactic sugar, incorporating features like properties, indexers, and events directly into the language.</li>
						<li>Both Java and C# boast extensive libraries and enjoy large user bases.</li>
					</ul>
					<p>
						<em>Can't really say much about C# from my own experience, I have used it very shortly.</em>
					</p>
				</div>
			</section>
<!--			<section>-->
<!--				<h3>PHP</h3>-->
<!--				<h3>Go</h3>-->
<!--				<h3>Rust</h3>-->
<!--				TODO-->
<!--			</section>-->
<!--			<section>-->
<!--				<h3>Scala</h3>-->
<!--				<div class="summary">-->
<!--					Scala is a powerful language compiled into Java bytecode. It actually runs on JVM, just like Java.-->
<!--				</div>-->
<!--				<div class="content">-->
<!--					<ul>-->
<!--						<li>Strong typing, enhanced safety, but mastering it may be challenging.</li>-->
<!--						<li>Modern syntax with type inference support.</li>-->
<!--						<li>High performance, with built-in support for parallel processing and concurrency through the actor model.</li>-->
<!--						<li>Designed for functional programming, while also supporting object-oriented programming.</li>-->
<!--						<li>Full interoperability with Java in both directions.</li>-->
<!--					</ul>-->
<!--				</div>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h3>Kotlin</h3>-->
<!--				<div class="summary">-->
<!--					Kotlin emerges as a leading alternative to Java. It also compiles to Java bytecode, therefore runs on JVM as well.-->
<!--				</div>-->
<!--				<div class="content">-->
<!--					<ul>-->
<!--						<li>It encompasses all of Java's features and more.</li>-->
<!--						<li>As a modern language, it introduces explicit null safety, implicit type inference, and functional programming support.</li>-->
<!--						<li>While not as robust as Scala, Kotlin has a gentler learning curve.</li>-->
<!--						<li>Supports concurrency through coroutines.</li>-->
<!--						<li>Just like Scala, Kotlin is interoperable with Java.</li>-->
<!--					</ul>-->
<!--				</div>-->
<!--				<div>-->
<!--					<img src="./img/heart.jpg" alt="I love Kotlin" style="width: 100px" />-->
<!--				</div>-->
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Object-oriented programming</h2>
			</section>
			<section>
				<h3>Object-oriented programming</h3>
				<div class="summary">
					There are four main principles in OOP ...
				</div>
				<div class="content">
					<ol>
						<li>
							<strong>Encapsulation</strong><br />
							is a concept of controlling access to the internal state of an object, protecting it from unauthorized access and ensuring data integrity.
						</li>
						<li>
							<strong>Inheritance</strong><br />
							enables class to have the same behavior as another class by inheriting its properties and methods.
						</li>
						<li>
							<strong>Polymorphism</strong><br />
							allows us to define one interface or method that can have multiple implementations.
							It means that the same method or property could exhibit different behavior in different instances of object implementing given interface.
						</li>
						<li>
							<strong>Abstraction</strong><br />
							is a mechanism to represent the object features without exposing the actual implementation details.
							In other words, user of such object only needs to know what it does, not how it does it.
						</li>
					</ol>
					<p>
						<em>We will come back to these principles later in the course.</em>
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Kotlin Language Syntax</h2>
				<em>Overview</em>
			</section>
			<section>
				<h3>Program entry point</h3>
				<div class="summary">
					Program entry point is the first function that is executed when the program is run.
				</div>
				<div class="content">
					<ul>
						<li>
							All Kotlin files should have <code class="hljs inline">.kt</code> extension, for example <code class="hljs inline">MyProgram.kt</code>.
						</li>
						<li>
							In Kotlin, the main program entry point is defined as a top-level function,
							which means that it is not part of a <em>class</em>.
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									fun main() {
										println("Hello world!")
									}
								</code>
							</pre>
						</li>
						<li>
							The main function may accept an <em>array of strings</em> as an argument,
							which can be used to pass command-line arguments to the program.
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									fun main(args: Array&lt;String&gt;) {
										println("Number of arguments: " + args.size)
										for (arg in args) {
											println("Argument: $arg")
										}
									}
								</code>
							</pre>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Functions</h3>
				<div class="summary">
					Function is declared using the <code class="hljs inline">fun</code> keyword, followed by the function name,
					parameters in parentheses, return type, and function body enclosed in curly braces.
				</div>
				<div class="content">
					<ul>
						<li>
							Function may have zero or more parameters, and it may return a value, in which case the return type is specified.
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									fun myFunction(arg1: Int, arg2: Int): Int {
										return arg1 + arg2
									}
								</code>
							</pre>
						</li>
						<li>
							If a function does not return a value, the return type is <code class="hljs inline">Unit</code>,
							but the return type can be omitted.
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									fun myFunction(arg1: Int, arg2: Int) {
										println(arg1 + arg2)
									}
								</code>
							</pre>
						</li>
<!--						<li>-->
<!--							Function can also be defined as a single expression function,-->
<!--							in which case the return type can be omitted as it is inferred by the compiler.-->
<!--							<pre>-->
<!--								<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--									fun myFunction(arg1: Int, arg2: Int) = arg1 + arg2-->
<!--								</code>-->
<!--							</pre>-->
<!--						</li>-->
					</ul>
					<br />
					<em>We will talk more about functions in lesson 2.</em>
				</div>
			</section>
			<section>
				<h3>Variables</h3>
				<div class="summary">
					Variables in Kotlin are declared using the <code class="hljs inline">var</code> or <code class="hljs inline">val</code> keyword,
					followed by the variable name, type, and optional value.
				</div>
				<div class="content">
					<ul>
						<li>
							Variables declared with <code class="hljs inline">var</code> are <strong>mutable</strong> = their value can be changed during the program execution.
						</li>
						<li>
							Variables declared with <code class="hljs inline">val</code> are <strong>immutable</strong> = their value cannot be changed once it is assigned = they are read-only.
						</li>
						<li>
							You can omit type in case variable is declared and initialized at the same time, it will be inferred by the compiler.
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									val myNumber = 42

									val myText = "Hello, world!"
								</code>
							</pre>
						</li>
						<li>
							If <strong>mutable</strong> variable is not initialized at the time of declaration, you must specify it's type.
							<pre>
								<code data-line-numbers data-trim data-noescape class="hljs kotlin">
									var myNumber: Int

									var myText: String
								</code>
							</pre>
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Classes</h3>
				<div class="summary">
					Classes in Kotlin are declared using the <code class="inline">class</code> keyword, followed by the class name,
					an optional constructor, and the class body enclosed in curly braces.
				</div>
				<div class="content">
					<ul>
						<li>Classes can have properties, functions, and multiple constructors.</li>
						<li>Classes are also usually part of a package, which is a way to organize classes into namespaces.</li>
						<li>
							Example:
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									package com.package.domain

									class MyClass {
										var myVariable: Int = 42
										val foo: Foo = Foo()

										/*
										Block comment
										*/
										fun myFunction(number: Long): String {
											// important comment
											return foo.bar()
										}
									}
								</code>
							</pre>
						</li>
					</ul>
					<br />
					<em>We will talk more about classes in lesson 2.</em>
				</div>
			</section>
			<section>
				<h3>Printing</h3>
				<div class="summary">
					You can use <code class="hljs inline">print</code> function to print on the same line,
					and <code class="hljs inline">println</code> function to print with a new line at the end.
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							fun main() {
								print("Hello, ")  // prints on one line
								println("world!") // prints on with a new line at the end
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Comments</h3>
				<div class="summary">
					You can use <code class="hljs inline">//</code> for single-line comments
					and <code class="hljs inline">/* */</code> for multi-line comments.
				</div>
				<div class="content">
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							// single-line comment

							/*
							Multi-line comment
							*/
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Naming Conventions</h3>
				<div class="summary">
					Kotlin naming conventions are similar to Java naming conventions ...
				</div>
				<div class="content">
					<ul>
						<li>
							<span class="highlight">Package</span> name is always written in all-lowercase.
						</li>
						<li>
							<span class="highlight">Class or interface</span> name should be nouns in mixed case with the first letter of each internal word capitalized. Should be sufficiently descriptive.
						</li>
						<li>
							<span class="highlight">Method</span> name should be verb, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.
						</li>
						<li>
							<span class="highlight">Variable</span> name should be in mixed case with a lowercase first letter. Internal words start with capital letters. Should be meaningful and descriptive
						</li>
						<li>
							<span class="highlight">Constants</span> name should be noun with each letter of internal word capitalized. Should be sufficiently descriptive.
						</li>
					</ul>
				<!--				<em style="font-size: 80%">-->
				<!--					Full set of recommendation by Oracle can be found <a href="https://www.oracle.com/java/technologies/javase/codeconventions-namingconventions.html">here</a>.-->
				<!--				</em>-->
				</div>
			</section>
		</section>

		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Kotlin Data Types</h2>
			</section>

			<section>
				<h3>Data types</h3>
				<div class="summary">
					Java/Kotlin is a high-level programming language with automatic memory management, and no pointers (unlike C/C++).
				</div>
				<div class="content content-center content-100">
					<strong>Why is this still important for us to understand?</strong>
				</div>
			</section>
			<section>
				<h2>Kotlin Data Types</h2>
				<div class="summary">
					Kotlin data representation is based on Java data types,
					<br />
					but with some key differences ...
				</div>
				<div class="content">
					<div class="row">
						<div class="column">
							<h4>Java</h4>
							<ul>
								<li>There are two groups of data types in Java - <strong>primitive</strong> and <strong>non-primitive</strong> types</li>
								<li>Primitive types are the basic data types that are built into the language.</li>
								<li>
									Primitive types
									<ul>
										<li>
											<code>byte</code>, <code>short</code>, <code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>char</code>, <code>boolean</code>
										</li>
									</ul>
								</li>
								<li>
									Non-primitive types
									<ul>
										<li>
											<code>String</code>, <code>Arrays</code>, <code>Classes</code>, ...
										</li>
									</ul>
								</li>
							</ul>
						</div>
						<div class="column">
							<h4>Kotlin</h4>
							<ul>
								<li>Kotlin has representation corresponding to Java primitive types, but unlike Java, they are all objects.</li>
								<li>Because they are objects, they have methods and properties.</li>
								<li>When Kotlin code gets compiled, the compiler will convert these objects to Java primitive types.</li>
							</ul>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Java Data Memory Representation</h3>
				<div class="content">
					<ul>
						<li>
							As already mentioned, Kotlin has representation corresponding to Java primitive types,
							<br />
							but unlike Java, they are all objects.
						</li>
						<li>
							Knowing what JVM primitive type they compile to is important for understanding how they are stored in memory.
						</li>
						<li>
							Understanding memory management, garbage collection, and type systems is crucial for writing efficient code,
							avoiding memory leaks, and preventing issues like data loss from type mismatches.
						</li>
						<li>
							It also helps debug errors, work with native code, and understand how systems operate under the hood.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Numeric Types</h3>
				<div class="content">
					<h4>Integer types</h4>
					<table style="width: 100%">
						<tbody>
						<tr><td><code>Byte</code></td><td>1 byte</td><td>whole number from -128 to 127</td></tr>
						<tr><td><code>Short</code></td><td>2 bytes</td><td>whole number from -32768 to 32767</td></tr>
						<tr><td><code>Int</code></td><td>4 bytes</td><td>whole number from -2147483648 to 2147483647</td></tr>
						<tr><td><code>Long</code></td><td>8 bytes</td><td>whole number from -9223372036854775808 to 9223372036854775807</td></tr>
						</tbody>
					</table>
					<br />
					<br />
					<h4>Unsigned Integer types</h4>
					<table style="width: 100%">
						<tbody>
						<tr><td><code>UByte</code></td><td>1 byte</td><td>whole number from 0 to 255</td></tr>
						<tr><td><code>UShort</code></td><td>2 bytes</td><td>whole number from 0 to 65535</td></tr>
						<tr><td><code>UInt</code></td><td>4 bytes</td><td>whole number from 0 to 4,294,967,295 (232 - 1)</td></tr>
						<tr><td><code>ULong</code></td><td>8 bytes</td><td>whole number from 0 to 18,446,744,073,709,551,615 (264 - 1)</td></tr>
						</tbody>
					</table>
					<br />
					<br />
					<h4>Floating-point types</h4>
					<table style="width: 100%">
						<tbody>
						<tr><td><code>Float</code></td><td>4 bytes</td><td>fractional number up to 7 decimal digits</td></tr>
						<tr><td><code>Double</code></td><td>8 bytes</td><td>fractional number up to 15 decimal digits</td></tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Numeric Types</h3>
				<div class="content">
					<h4>Integer types</h4>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val index: Byte = 127
							val smallNumber: Short = 32767
							val number: Int = 2147483647
							val bigNumber: Long = 9223372036854775807L // notice L at the end
						</code>
					</pre>
					<h4>Unsigned integer types</h4>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val uIndex: UByte = 255u // u indicates unsigned type
							val uSmallNumber: UShort = 65535u
							val uNumber: UInt = 4294967295u
							val uBigNumber: ULong = 18446744073709551615u
						</code>
					</pre>
					<h4>Floating-point types</h4>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val decimalNumber: Float = 123.12346f // f indicates float type
							val preciseNumber: Double = 123.12345886230469
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>The two's complement</h3>
				<div class="summary">
					In Java/Kotlin, two's complement is used for the representation of signed integers.
					A negative number is represented as the two's complement of its absolute value.
					This allows positive and negative numbers to be added together directly.
				</div>
				<div class="content">
					<ul>
						<li>
							<strong>For positive integers</strong>, the two's complement representation is the same as their binary representation.
						</li>
						<li>
							<strong>For negative integers</strong>, you use binary representation of the absolute value of the number, then you invert each bit, and finally add 1 to the least significant bit (LSB).
						</li>
					</ul>
					<blockquote>
						<strong>Example: Binary representation of -5</strong>
						<ol>
							<li>The binary representation of absolute value of -5 (=5) is <code>0101</code></li>
							<li>Inverting each bit gives you <code>1010</code></li>
							<li>Adding 1 to the least significant bit gives you the binary representation of -5, which is: <code>1011</code></li>
						</ol>
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Literal constants for numbers</h3>
				<div class="content">
					<p>
						It is sometimes practical to represent data in binary or hexadecimal format to make the code more readable.
					</p>
					<p>
						You do that by prefixing the number with <code><strong>0b</strong></code> followed by 1s and 0s for binary representation,
						<br />
						or <code><strong>0x</strong></code> followed by characters or hexadecimal representation.
					</p>
					<table style="width: 100%">
						<tbody>
						<tr>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										fun main() {
											val binaryInt = 0b00001010
											println(binaryInt) 			// prints 10
											println(binaryInt == 10) 	// prints true
										}
									</code>
								</pre>
							</td>
							<td>
								<strong>Examples:</strong>
								<br />
								<br />
								<code>0b0</code> = 0<br />
								<code>0b1</code> = 1<br />
								<code>0b00001010</code> = 10<br />
							</td>
						</tr>
						<tr>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										fun main() {
											val hexInt = 0x00AA
											println(hexInt) 		// prints 170
											println(hexInt == 170) 	// prints true
										}
									</code>
								</pre>
							</td>
							<td>
								<strong>Examples:</strong>
								<br />
								<br />
								<code>0x0</code> = 0<br />
								<code>0xF</code> = 15<br />
								<code>0x00AA</code> = 170<br />
							</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Non-numeric Data Types</h3>
				<div class="content">
					<table>
						<tbody>
						<tr><td><code>Boolean</code></td><td>1 byte</td><td>value of true or false</td></tr>
						<tr><td><code>Char</code></td><td>2 bytes</td><td>a single 16-bit Unicode character</td></tr>
						<tr><td><code>String</code></td><td>approximately 2 bytes per character</td><td>UTF-16 encoded string of characters</td></tr>
						<tr><td><code>Array</code></td><td>depends</td><td>
							Fixed number of values of the same type or its subtypes.
						</td></tr>
						</tbody>
					</table>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val isTrue: Boolean = true
							val character: Char = 'A'
							val text: String = "Hello, world!"

							val arrayOfStrings = arrayOf("hello", "world", "kotlin", "is", "fun")

							println(arrayOfStrings[2]) // will print "kotlin"
						</code>
					</pre>
					<em>Unless there are specific memory performance requirements, you should prefer using Collections over Arryas.</em>
				</div>
			</section>
			<section>
				<h3>Arrays</h3>
				<div class="summary">
					Arrays are used to store multiple values of the same type in one variable.
					<br />
					Arrays are of fixed size, which means that once you declare an array, you cannot change its size.
				</div>
				<div class="content">
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val languages = arrayOf("Java", "Kotlin", "Python")

							println(languages.size)  // will print 3
							println(languages[1])    // will print "Kotlin"
						</code>
					</pre>
					<p>
						You can change value of an array by its index (zero-based).
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								languages[2] = "JavaScript"
							</code>
						</pre>
					</p>
					<p>
						If you try to assign value outside of array bound, you will get an error.
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								println(languages[3])  // java.lang.ArrayIndexOutOfBoundsException: Index 1 out of bounds for length 0
							</code>
						</pre>
					</p>
					<p>
						Arrays are fixed size, but you can create a new array with a different size and copy values from the old array.
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								val updatedLanguage = languages.plus("Go") // will contain "Java", "Kotlin", "Python", "Go"
							</code>
						</pre>
					</p>
					<p>
						You can also create an empty array. In this case, you need to specify the type of the array.
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								val emptyArray = emptyArray&lt;String&gt;()
							</code>
						</pre>
					</p>
				</div>
			</section>
			<section>
				<h3>Collections</h3>
				<div class="summary">
					Collections are similar to arrays, but they are more flexible and have more features at the cost
					of being less efficient in terms of memory and performance.
				</div>
				<div class="content">
					<p>
						The main difference between arrays and collections is that collections can grow or shrink in size.
						They generally provide more functionality and are easier to work with than arrays, but also
						are less efficient in terms of memory and performance.
					</p>
					<p>
						There are several types of collections in Kotlin, such as <code>List</code>, <code>Set</code>, <code>Map</code>, etc.
					</p>
					<p>
						Unlike and array, which is basic data structure, collections are interfaces that define a set of operations that can be performed on a group of objects.
					</p>
					<p>
						<em>We will learn in detail about collections in the future lesson.</em>
					</p>
				</div>
			</section>
			<section>
				<h3>Any type</h3>
				<div class="summary">
					<code class="hljs inline">Any</code> is the root of the Kotlin class hierarchy.
					<br />
					This means that all type classes in Kotlin are subclasses of <code class="hljs inline">Any</code>.
				</div>
				<div class="content">
					<p>
						Anytime we don't know the type of variable, parameter or return type,
						we can use <code class="hljs inline">Any</code> to accept any type.
						However, this is not recommended and should be used with caution.
					</p>
					<p>
						Any type is equivalent to Java's <code class="hljs inline">Object</code> type.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val someValue: Any = "This is a string"

							if (someValue is String) {
								println("The value is a string")
							} else {
								println("The value is not a string")
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>null</h3>
				<div class="summary">
					In Java/Kotlin, null is a special value that represents the absence of an instance.
					<br />
					It is used to indicate that a reference variable doesn't point to any memory location or object.
					<br />
					(Therefore by definition, primitive types cannot be null)
				</div>
				<div class="content">
					<p>
						Some key point to keep in mind when working with nulls in Java/Kotlin code ...
					</p>
					<ul>
						<li>
							Since Kotlin and Java are interoperable, you may need to explicitly handle null values when calling Java methods from Kotlin.
						</li>
						<li>
							In Java
							<ul>
								<li>you can assign null to any <strong>reference variable</strong> (non-primitive types: objects, array, interface, etc)</li>
								<li>for object reference types, the default value is null when they are defined as class members and not explicitly initialized</li>
								<li>If you try to invoke a method or access a property on a reference variable with a null value, you will get a <strong>NullPointerException</strong>. This is a runtime exception in Java.</li>
							</ul>
						</li>
						<li>
							In Kotlin, object references that may hold null values must be explicitly declared as <strong>nullable</strong> types.
						</li>

						<li>
							You can use null in comparison operations. For example, to check if an object is null, you can use if (object == null).
						</li>
						<li>
							Assigning null to a variable makes it eligible for <strong>garbage collection</strong> if there are no other references to the object.
						</li>
						<li>
							Null can be passed as an argument to a method and can also be returned from a method.
						</li>
					</ul>
				</div>
			</section>

			<section>
				<h3>Nullables</h3>
				<div class="summary">
					Nullables are Kotlin types that can hold a null value.
					<br />
					Any type can be nullable by adding a <code class="hljs inline">?</code> after the type.
					<br />
					<br />
					When working with nullable types, you need to handle null values to avoid <strong>NullPointerException</strong>.
				</div>
				<div class="content">
					<div class="row">
						<pre>
							<code data-trim data-noescape class="hljs kotlin">
								val nullableNumber: Int? = null
								val nullableText: String? = null
							</code>
						</pre>
					</div>
					<div class="row">
						<div class="column" style="font-size: 80%">
							You can use the <code class="hljs inline">?.</code> operator to safely access properties or methods of nullable types.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									nullableNumber?.toString()
								</code>
							</pre>
						</div>
					</div>
					<div class="row">
						<div class="column" style="font-size: 80%">
							You can use the <code class="hljs inline">!!</code> operator to tell the compiler that you are sure the value is not null.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									nullableNumber!!.toString()
								</code>
							</pre>
						</div>
					</div>
					<div class="row">
						<div class="column" style="font-size: 80%">
							You can also use the <code class="hljs inline">?:</code> elvis operator to provide a default value if the value is null.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									val text = nullableText ?: "default"
								</code>
							</pre>
						</div>
					</div>
					<div class="row">
						<div class="column" style="font-size: 80%">
							Use the <code class="hljs inline">let</code> function to execute a block of code only if the value is not null.
						</div>
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									nullableText?.let { printText(it) }
								</code>
							</pre>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Type inference & Type checks</h3>
				<div class="summary">
					Type inference is a feature that allows the compiler to automatically determine the data type of a variable based on the value assigned to it.
				</div>
				<div class="content">
					<p>
						For example, this is how you can declare a variable with type inference:
						<pre>
							<code data-trim data-noescape class="hljs kotlin">
								val number = 42             // type inferred as Int
								val text = "Hello, world!"  // type inferred as String
							</code>
						</pre>
					</p>
					<p>
						You can check the type of variable using the <code class="hljs inline">is</code> operator.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun getSomething(): Any {
								return 1234567890
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val something = getSomething()

							println(something is Int)			 // true
							println(something is Long)			 // false
							println(something::class.simpleName) // Int
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Type Conversion</h3>
				<div class="summary">
					Type conversion is a method of converting one data type to another.<br />
					Keep in mind, that type conversion may result in data loss!
				</div>
				<div class="content">
					<h4>Type Casting</h4>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							fun getSomething(): Any {
								return 1234567890
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val something = getSomething()

							// Explicit type casting, only works if the value is of the same type
							val number = something as Int
						</code>
					</pre>
					<h4>Type Conversion</h4>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val number = 1234567890
							val bigNumber = number.toLong() // Type conversion, no data loss
							val smallNumber = number.toShort() // Type conversion with DATA LOSS!
						</code>
					</pre>
					<p>
						Assigning smaller data type to larger data type - generally doesn't result in data loss.
					</p>
					<p>
						Assigning larger data type to smaller data type - may result in data loss.
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Operators</h2>
			</section>
			<section>
				<h3>Operators</h3>
				<div class="content content-center content-100">
					<ul>
						<li>Assignment operators</li>
						<li>Arithmetic operators</li>
						<li>Comparison operators</li>
						<li>Logical operators</li>
						<li>Bitwise operators</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Assignment Operators</h3>
				<div class="summary">
					Assignment operators are used to assign value to <strong>variable</strong> or <strong>constant</strong>.
				</div>
				<div class="content">
					Variables and constants don't need to have explicit type declaration,
					in case the compiler can infer the type from the value assigned to it.
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							val number = 3
							val text = "Hello"
							val date = LocalDate()
						</code>
					</pre>
					Variables and constants can be declared as <strong>read-only</strong>, using <code>val</code> keyword,
					or <strong>mutable</strong>, using <code>var</code> keyword.
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									var name: String = "John"
									name = "Jane"
									println(name)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							Mutable variable value can be changed during the program execution.
						</div>
					</div>
					<div class="row">
						<div class="column">
							<pre>
								<code data-trim data-noescape class="hljs kotlin">
									val name: String = "John"
									name = "John"
									println(name)
								</code>
							</pre>
						</div>
						<div class="column">
							<br />
							This will throw an error, because name is declared as read-only.
						</div>
					</div>
				</div>
				<br />
				<blockquote>
					Can you think of reason why we would want to declare a variable as read-only and reasons why we would want to declare a variable as mutable?
				</blockquote>
			</section>
			<section>
				<h3>Arithmetic Operators</h3>
				<div class="summary">
					Given two variables <code class="hljs inline">var a = 5</code> and <code class="hljs inline">var b = 2</code>.
				</div>
				<div class="content" style="font-size: 70%">
					<table>
						<tbody>
						<tr>
							<td><code>+</code></td>
							<td>addition</td>
							<td style="min-width: 300px">
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val sum = a + b
										</code>
									</pre>
							</td>
							<td>
								a = 5, b = 2, sum = 7
							</td>
						</tr>
						<tr>
							<td><code>-</code></td>
							<td>subtraction</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val difference = a - b
										</code>
									</pre>
							</td>
							<td>
								a = 5, b = 2, difference = 3
							</td>
						</tr>
						<tr>
							<td><code>*</code></td>
							<td>multiplication</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val product = a * b
										</code>
									</pre>
							</td>
							<td>
								a = 5, b = 2, product = 10
							</td>
						</tr>
						<tr>
							<td><code>/</code></td>
							<td>division</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val quotient = a / b
										</code>
									</pre>
							</td>
							<td>
								a = 5, b = 2, quotient = 2 (integer division)
							</td>
						</tr>
						<tr>
							<td><code>%</code></td>
							<td>modulus</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val remainder = a % b
										</code>
									</pre>
							</td>
							<td>
								a = 5, b = 2, remainder = 1
							</td>
						</tr>
						<tr>
							<td><code>++</code></td>
							<td>increment (by 1)</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val increment1 = ++a
											val increment2 = a++
										</code>
									</pre>
							</td>
							<td>
								a = 7, increment1 = 6, increment2 = 6
							</td>
						</tr>
						<tr>
							<td><code>--</code></td>
							<td>decrement (by 1)</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val decrement1 = --b
											val decrement2 = b--
										</code>
									</pre>
							</td>
							<td>
								b = 1, decrement1 = 0, decrement2 = 0
							</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Arithmetic Operators</h3>
				<blockquote style="font-size: 80%">
					Notice ++ and -- can be put before or after a value. What is the difference?
					<br />
					<br />
					What will this print?
					<pre>A)
						<code data-trim data-noescape class="hljs kotlin">
							var a = 0
							println(a++)
						</code>
						<span class="fragment fade-in">0, because is incremented (by 1) after it is printed</span>
					</pre>
					<pre>B)
						<code data-trim data-noescape class="hljs kotlin">
							var a = 0
							println(++a)
						</code>
						<span class="fragment fade-in">1, because is incremented (by 1) before it is printed</span>
					</pre>
					<pre>C)
						<code data-trim data-noescape class="hljs kotlin">
							val a: Int = 5
							val b: Int = 3

							println(a / b)
						</code>
						<span class="fragment fade-in">
							1, because 5 / 3 = 1.666666666666667, but since it is stored as integer, the decimal places are dropped
						</span>
					</pre>
					<pre>D)
						<code data-trim data-noescape class="hljs kotlin">
							val a: Int = 5
							val b: Int = 3

							println(a % b)
						</code>
						<span class="fragment fade-in">
							2, because remainder of integer 5 /3 is 2
						</span>
					</pre>
				</blockquote>
			</section>
			<section>
				<h3>Comparison Operators</h3>
				<div class="summary">
					As the name suggest, comparison operators are used for comparing values.
					<br />
					They always yield a <b>boolean</b> value.
				</div>
				<div class="content">
					<table>
						<tbody>
						<tr>
							<td><code>==</code></td>
							<td>equals</td>
							<td style="min-width: 300px">
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isEqual = a == b
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code>!=</code></td>
							<td>not equals</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isNotEqual = a != b
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code>></code></td>
							<td>is greater</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isGreater = a > b
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code><</code></td>
							<td>is less</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isLess = a > b
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code>>=</code></td>
							<td>is greater or equal</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isGreaterOrEqual = a >= b
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code><=</code></td>
							<td>is less or equal</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isLessOrEqual = a >= b
									</code>
								</pre>
							</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Comparison Operators</h3>
				<blockquote>
					Given these values, what will be the value of <b>result</b>?
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val a = 5
							val b = 3
							val c = 2
						</code>
					</pre>
					<pre>A)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = a > b
						</code>
					</pre>
					<pre>B)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = a <= b
						</code>
					</pre>
					<pre>C)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = a > (b + c)
						</code>
					</pre>
					<pre>D)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = a >= (b + c)
						</code>
					</pre>
				</blockquote>
			</section>
			<section>
				<h3>Logical Operators</h3>
				<div class="summary">
					Logical operators are used to evaluate logic between variables or values.
					<br />
					They always yields boolean value.
				</div>
				<div class="content">
					<table>
						<tbody>
						<tr>
							<td><code>&&</code></td>
							<td>logical and</td>
							<td>returns true if both statements are true</td>
							<td style="min-width: 450px">
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val isTrue = statement1 && statement2
										</code>
									</pre>
							</td>
						</tr>
						<tr>
							<td><code>||</code></td>
							<td>logical or</td>
							<td>returns true if either statement is true</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val isEitherTrue = statement1 || statement2
										</code>
									</pre>
							</td>
						</tr>
						<tr>
							<td><code>!</code></td>
							<td>logical not</td>
							<td>reverses the result</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val neitherIsTrue = !(statement1 || statement2)
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code>and</code></td>
							<td>logical and</td>
							<td>
								works same as && but doesn't short-circuit
							</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val isTrue = statement1 and statement2
									</code>
								</pre>
							</td>
						</tr>
						<tr>
							<td><code>or</code></td>
							<td>logical or</td>
							<td>
								works same as || but doesn't short-circuit
							</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val neitherIsTrue = !(statement1 or statement2)
									</code>
								</pre>
							</td>
						</tr>
						</tbody>
					</table>
				</div>
				<div>
					<blockquote>
						Short circuiting means that if the first part of the statement is false,
						the second part will not be evaluated.
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Logical Operators</h3>
				<blockquote style="font-size: 80%">
					Given two string variables that can have values <code>cat</code>, <code>dog</code>, or <code>null</code>.
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val pet1: String? = "cat"
							val pet2: String? = null
						</code>
					</pre>

					How would you test if ...

					<br />
					<br />
					A) pet1 and pet2 are the same kind of pet?
					<div class="fragment fade-in">
						<pre >
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								val hasTwoSamePets = pet1 == pet2
							</code>
						</pre>
					</div>

					B) pet1 and pet2 are both cats?
					<div class="fragment fade-in">
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								val has2Cats = pet1 == "cat" && pet2 == "cat"
							</code>
						</pre>
					</div>

					C) At least one of pet1 and pet2 is a cat?
					<div class="fragment fade-in">
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								val hasACat = pet1 == "cat" || pet2 == "cat"
							</code>
						</pre>
					</div>

					D) At least one of pet1 and pet2 is a pet (not null)?
					<div class="fragment fade-in">
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								val hasAPet = pet1 != null || pet2 != null
							</code>
						</pre>
					</div>
				</blockquote>
			</section>
			<section>
				<h3>Bitwise Operators</h3>
				<div class="content">
					<table style="font-size: 60%">
						<tbody>
						<tr>
							<td><code>and</code></td>
							<td>binary and</td>
							<td>sets bit to 1 if both bits at the same positions are 1</td>
							<td style="min-width: 450px">
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val a = 5 // binary: 0101
											val b = 3 // binary: 0011

											val result = a and b // binary: 0001, decimal: 1
										</code>
									</pre>
							</td>
							<td>
								binary: <code>0001</code>, decimal: <code>1</code>
							</td>
						</tr>
						<tr>
							<td><code>or</code></td>
							<td>binary or</td>
							<td>sets bit to 1 if either of bits at the same positions are 1</td>
							<td style="min-width: 450px">
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val a = 5 // binary: 0101
											val b = 3 // binary: 0011

											val result = a or b // binary: 0111, decimal: 7
										</code>
									</pre>
							</td>
							<td>
								binary: <code>0111</code>, decimal: <code>7</code>
							</td>
						</tr>
						<tr>
							<td><code>xor</code></td>
							<td>binary xor</td>
							<td>sets bit to 1 if of bits at the same positions are different</td>
							<td style="min-width: 450px">
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val a = 5 // binary: 0101
											val b = 3 // binary: 0011

											val result = a xor b // binary: 0110, decimal: 6
										</code>
									</pre>
							</td>
							<td>
								binary: <code>0110</code>, decimal: <code>6</code>
							</td>
						</tr>
						<tr>
							<td><code>shl</code></td>
							<td>signed left shift</td>
							<td>moves all bits by a given number of bits to the left</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val a = 5 // binary: 0101

											val result = a shl 1 // binary: 1010, decimal: 10
										</code>
									</pre>
							</td>
							<td>
								binary: <code>1010</code>, decimal: <code>10</code>
							</td>
						</tr>
						<tr>
							<td><code>shr</code></td>
							<td>signed right shift</td>
							<td>moves all bits by a given number of bits to the right</td>
							<td>
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val a = 5 // binary: 0101

											val result = a shr 2 // binary: 0001, decimal: 1
										</code>
									</pre>
							</td>
							<td>
								binary: <code>0001</code>, decimal: <code>1</code>
							</td>
						</tr>
						<tr>
							<td><code>ushr</code></td>
							<td>unsigned right shift</td>
							<td>same as the signed right shift, but the vacant leftmost position is filled with 0 instead of the sign bit</td>
							<td>
								<pre>
									<code data-trim data-noescape class="hljs kotlin">
										val a = -5 // binary equivalent of -5: 11111111111111111111111111111011

										val result = a ushr 1 // shifts right with zero fill
									</code>
								</pre>
							</td>
							<td>
	<!--							binary: <code>01111111111111111111111111111101</code>, decimal: <code>2147483645</code>-->
							</td>
						</tr>
						<tr>
							<td><code>.inv()</code></td>
							<td>binary complement operator</td>
							<td>flips all the bits of the operand 1s become 0s, and 0s become 1s</td>
							<td style="min-width: 450px">
									<pre>
										<code data-trim data-noescape class="hljs kotlin">
											val a = 5 // binary: 0101

											val result = a.inv() // binary: 1010, decimal: -6
										</code>
									</pre>
							</td>
							<td>
								binary: <code>1010</code>, decimal: <code>-6</code>
							</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>Bitwise Operators</h3>
				<blockquote style="min-width: 800px; font-size: 80%;">
					Imagine you have a <b>byte</b> stored in 1 byte (=8 bits), for example 8, which is stored as
					<code>00001000</code>
					<br />
					<br />
					If you perform following bit shift, what number do you get?
					<pre>A)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val number: Byte = 8
							val result = number << 1
						</code>
						<span class="fragment fade-in">
							The result is 16:<br />
							In binary: 1000 <- 10000
						</span>
					</pre>
					<pre>B)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val number: Byte = 8
							val result = number << 3
						</code>
						<span class="fragment fade-in">
							The result is 64:<br />
							In binary: 1000 <--- 1000000
						</span>
					</pre>
					<pre>C)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val number: Byet = -8
							val result = number >> 2
						</code>
						<span class="fragment fade-in">
							The result is -2:<br />
							In binary: 11111111111111111111111111111000 --> 11111111111111111111111111111110
						</span>
					</pre>
					<pre>D)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val number: Byte = -8
							val result = number >>> 2
						</code>
						<span class="fragment fade-in">
							The result is 1073741822:<br />
							In binary: 11111111111111111111111111111000 --> __111111111111111111111111111110
						</span>
					</pre>
				</blockquote>
			</section>
			<section>
				<h3>Bitwise Operators</h3>
				<blockquote style="font-size: 80%">

					What will be the result of following bit operations?

					<pre>A)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val a: Byte = 21 // 00010101
							val b: Byte = 81 // 01010001
							val result = a & b
						</code>
						<span class="fragment fade-in">
							The result is 17:<br />
							In binary: 00010101 & 01010001 = 00010001
						</span>
					</pre>

					<pre>B)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val a: Byte = 21 // 00010101
							val b: Byte = 81 // 01010001
							val result = a | b
						</code>
						<span class="fragment fade-in">
							The result is 85:<br />
							In binary: 00010101 & 01010001 = 01010101
						</span>
					</pre>

					<pre>C)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val a: Byte = 21 // 00010101
							val b: Byte = 81 // 01010001
							val result = a ^ b
						</code>
						<span class="fragment fade-in">
							The result is 68:<br />
							In binary: 00010101 & 01010001 = 01000001
						</span>
					</pre>

					<pre>D)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val a: Byte = 21 // 00010101
							val result = ~a
						</code>
						<span class="fragment fade-in">
							The result is -22:<br />
							In binary: 00010101 -> 11101010
						</span>
					</pre>
				</blockquote>
			</section>
			<section>
				<h3>Addition Assignment</h3>
				<div class="summary">
					Combines assignment operators with arithmetic operators.
				</div>
				<div class="content">
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							var number = 0

							number += 3 // equivalent: number = number + 3

							number -= 3 // equivalent: number = number - 3

							number *= 3 // equivalent: number = number / 3

							number /= 3 // equivalent: number = number * 3

							number %= 3 // equivalent: number = number % 3
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Conditionals</h2>
				<em>Control Flow Statements</em>
			</section>
			<section>
				<h3>if ... else if ... else</h3>
				<div class="summary">
					Because Kotlin, like Java is based on C++ syntax, you can expect similar control flow statements.
				</div>
				<div class="content">
					You can write just simple <b>if</b> statement ...
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							if (a <= b) {
								// execute if condition is met
							}
						</code>
					</pre>

					<b>else</b> branch is not required, but it is highly recommendable ...
					<pre>
					<code data-line-numbers data-trim data-noescape class="hljs kotlin">
						if (a <= b) {
							// execute if condition is met
						} else {
							// execute if condition is NOT met
						}
					</code>
				</pre>
					You can also evaluate multiple conditions with <b>else if</b>.
					<pre>
					<code data-line-numbers data-trim data-noescape class="hljs kotlin">
						if (a < b) {
							// execute if first condition is met
						} else if (a == b) {
							// execute if second condition is met
						} else if (a == null) {
							// execute if third condition is met
						} else {
							// execute if no condition is NOT met
						}
					</code>
				</pre>
				</div>
			</section>
			<section>
				<h3>if ... else if ... else</h3>
				<div class="summary">
					Kotlin allows you to return value from if else statement.
				</div>
				<div class="content">
					Traditionally, you would write this code ...
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							var result: String? = null

							if (a < b) {
								result = "a is less than b"
							} else if (a == b) {
								result = "a is equal to b"
							} else {
								result = "a is greater than b"
							}
						</code>
					</pre>
					Kotlin allows you to write this in a more concise way.
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = if (a < b) {
								"a is less than b"
							} else if (a == b) {
								"a is equal to b"
							} else {
								"a is greater than b"
							}
						</code>
					</pre>
					Kotlin has no tenary operator like Java, but you can use if else as a replacement.
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = if (a < b) "a is less than b" else "a is greater than or equal to b"
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>when</h3>
				<div class="summary">
					One of the most powerful control flow statements in Kotlin is <b>when</b>.
					<br />
					It is similar to <b>switch</b> in Java, but it is more powerful.
				</div>
				<div class="content">
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val randomInt = arrayOf(0, 1, 2, 3, 4, 5).random()
						</code>
					</pre>
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = when (randomInt) {
								0 -> "Zero"
								1 -> "One"
								2 -> "Two"
								3 -> "Three"
								4 -> "Four"
								5 -> "Five"
								else -> "Too much"
							}
						</code>
					</pre>
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = when {
								randomInt < 0 -> "Less than 0"
								randomInt == 0 -> "Zero"
								else -> "Greater than 0"
							}
						</code>
					</pre>
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val result = when (randomInt) {
								0 -> "Zero"
								in 1..3 -> "Between 1 and 3"
								in 3..5 -> "Between 3 and 5"
								else -> "Too much"
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>For Loop</h3>
				<div class="summary">
					The for loop is used to iterate over anything that provides an iterator, such as a range, array, or a collection.
				</div>
				<div class="content">
					<div>
						The basic syntax of for loop is ...
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								for (item in collection) println(item)
							</code>
						</pre>
						or the body can be a block ...
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								val languages = arrayOf("Java", "Kotlin", "Python")

								for (language in languages) {
									println(language)
								}
							</code>
						</pre>
					</div>
					<div>
						You can also use range expression to iterate over a range of numbers.
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								for (i in 10 downTo 0 step 2) {
									println(i)
								}
							</code>
						</pre>
						<pre>
							<code data-line-numbers data-trim data-noescape class="hljs kotlin">
								for (i in 1..5) {
									println(i)
								}
							</code>
						</pre>
					</div>
				</div>
			</section>
			<section>
				<h3>While Loop / Do While Loop</h3>
				<div class="summary">
					While loop is used to execute a block of code repeatedly as long as a given condition is true.
				</div>
				<div class="content">
					<p>The <b>while</b> evaluates condition at the beginning of the loop block, before any code is executed.</p>
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							while (condition) {
							  // code block to be executed
							}
						</code>
					</pre>
					<p>The <b>do while</b> first executes code block once, and evaluates condition the condition.</p>
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							do {
							  // code block to be executed
							} while (condition)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>While Loop / Do While Loop</h3>
				<blockquote>
					How may times will "Ahoy!" be printed?
					<pre>A)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							var counter = 10

							while (counter < 10) {
								println("Ahoy!")
								counter++
							}
						</code>
						<span class="fragment fade-in">0 - it will never be printed</span>
					</pre>
					<pre>B)
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							var counter = 10

							do {
								println("Ahoy!")
								counter++
							} while (counter < 10)
						</code>
						<span class="fragment fade-in">1 - once</span>
					</pre>
				</blockquote>
			</section>
<!--			<section>-->
<!--				<h4>For Loop</h4>-->
<!--				<blockquote>-->
<!--					How many times will this loop execute and what will be the values printed?-->
<!--					<pre>-->
<!--							<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--								for (i in 1 .. 10 step 2) {-->
<!--									println(i)-->
<!--								}-->
<!--							</code>-->
<!--						</pre>-->
<!--					<div class="fragment fade-in">-->
<!--						5 times. Values printed will be 1, 3, 5, 7 and 9.-->
<!--					</div>-->
<!--				</blockquote>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h4>For Each Loop</h4>-->
<!--				<div style="text-align: left">-->
<!--					<p>If you have an array, can iterate it using for loop.</p>-->
<!--					<pre>-->
<!--						<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--							String[] languages = {"Java", "Python", "C++", "JavaScript"}-->

<!--							for (int i = 0 i < languages.length i++) {-->

<!--								System.out.println(languages[i])-->

<!--							}-->
<!--						</code>-->
<!--					</pre>-->
<!--					<p>You can also use more convenient <b>for each</b> loop.</p>-->
<!--					<pre>-->
<!--						<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--							String[] languages = {"Java", "Python", "C++", "JavaScript"}-->

<!--							for (String language : languages) {-->

<!--								System.out.println(language)-->

<!--							}-->
<!--						</code>-->
<!--					</pre>-->
<!--				</div>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h4>Break / Continue</h4>-->
<!--				<div style="text-align: left">-->
<!--					<p>The <b>break</b> statement is used to end the loop immediately.</p>-->
<!--					<pre>-->
<!--						<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--							for (int i = 0 i < x i++) {-->

<!--								if (breakCondition) {-->
<!--									break-->
<!--								}-->

<!--							}-->
<!--							// if breakCondition was met, the loop will end-->
<!--						</code>-->
<!--					</pre>-->
<!--					<p>The <b>continue</b> statement is end current iteration, but the loop will continue with next iteration.</p>-->
<!--					<pre>-->
<!--						<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--							for (int i = 0 i < x i++) {-->

<!--								if (continueCondition) {-->
<!--									continue-->
<!--								}-->

<!--								// if continueCondition was met, this code will not be executed-->
<!--							}-->
<!--						</code>-->
<!--					</pre>-->
<!--				</div>-->
<!--			</section>-->
<!--			<section>-->
<!--				<h4>Break / Continue</h4>-->
<!--				<blockquote>-->
<!--					What values will be printed?-->
<!--					<pre>-->
<!--					<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--						int maxValue = 10-->
<!--						int significantValue = 7-->

<!--						for (int i = 0 i < maxValue i++) {-->

<!--							if (i == significantValue) {-->
<!--								break-->
<!--							}-->

<!--							System.out.println(i)-->
<!--						}-->
<!--					</code>-->
<!--					<span class="fragment fade-in">-->
<!--						1, 2, 3, 4, 5, 6, 7-->
<!--					</span>-->
<!--				</pre>-->
<!--					<pre>-->
<!--					<code data-line-numbers data-trim data-noescape class="hljs kotlin">-->
<!--						int maxValue = 10-->
<!--						int significantValue = 7-->

<!--						for (int i = 0 i < maxValue i++) {-->

<!--							if (i == significantValue) {-->
<!--								continue-->
<!--							}-->

<!--							System.out.println(i)-->
<!--						}-->
<!--					</code>-->
<!--					<span class="fragment fade-in">-->
<!--						1, 2, 3, 4, 5, 6, 8, 9-->
<!--					</span>-->
<!--				</pre>-->
<!--				</blockquote>-->
<!--			</section>-->
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Working with Strings</h2>
			</section>
			<section>
				<h3>Working with Strings</h3>
				<div class="content">
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							/*
							 Printing to console
							 */
							println("Printing to console with new line at the end")
							print("Printing to console without new line at the end")
							println() // just new line

							/*
							 String concatenation using the + operator
							 */
							val name = "Moni"
							val hello = "Hello"

							val greeting = hello + " " + name + "!"
							println(greeting)

							/*
							 String interpolation
							 */
							val fullGreeting = "$hello $name"
							println(fullGreeting)

							/*
							 String concatenation using the += operator
							 */
							var greeting2 = "Hola"
							greeting2 += " $name!" // Assignment addition String concatenation
							println(greeting2)

							/*
							 String formatting
							 */
							val formattedGreeting = String.format("%s %s!", hello, name) // String formatting
							println(formattedGreeting)
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Working with Strings</h3>
				<div class="content">
					<pre>
						<code data-line-numbers data-trim data-noescape class="hljs kotlin">
							val text = "Banana, Apple, Orange, Kiwi, Mango, Pineapple, Watermelon, Strawberry"

							/*
							 Find the length of the text
							 */
							println("Length: " + text.length)

							/*
							 Split the text into an array of fruits
							 */
							val fruits = text.split(",".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
							for (fruit in fruits) {
								println(fruit.trim { it <= ' ' }) // trim to remove leading or trailing space
							}

							/*
							 Check if the text contains "Apple"
							 */
							println("Has apple: " + text.contains("Apple"))
							println(text.uppercase())
							println(text.lowercase())
							println(text.substring(10, 20))

							/*
							 Replace all occurrences of "Apple" with "Peach"
							 */
							val newText = text.replace("Apple", "Peach")
							println(newText)
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Integrated Development Environment (IDE)</h2>
			</section>
			<section>
				<h3>What is Integrated Development Environment (IDE)</h3>
				<div class="summary">
					Being able to efficiently use an IDE is just as important as being able to write code.<br />
					Gives you a set of tools that you need as a developer.
				</div>
				<div class="content">
					<ul>
						<li>Provides code editor with syntax highlighting</li>
						<li>Easy ways for manage our code, project and builds</li>
						<li>
							Helps your productivity
							<div>
								<em>contextual suggestions</em>,
								<em>autocomplete</em>,
								<em>code navigation</em>,
								<em>refactoring</em>,
								<em>language tip</em>
							</div>
						</li>
						<li>
							Helps you avoid some errors in your programs
							<div>
								<em>can warn you about problematic code</em><br />
								<em>gives you tools inspect your code</em><br />
								<em>gives you tools test your code</em>
							</div>
						</li>
						<li>Integrates tools
							<div>
								<em>source code management, such as git</em><br />
								<em>database clients</em><br />
								<em>documentation</em><br />
								<em>project management tools</em><br />
								<em>AI</em>
							</div>
						</li>
						<li>Usually has a community led plugin ecosystem</li>
					</ul>
				</div>
			</section>
			<!--			<section>-->
			<!--				<h3>Popular Java IDEs</h3>-->
			<!--				<h2>IntelliJ IDEA</h2>-->
			<!--				<p>We will be working with <b>IntelliJ IDEA</b>, which is a very popular and very powerful IDE.</p>-->
			<!--				<p>NetBeans</p>-->
			<!--				<p>Eclipse</p>-->
			<!--			</section>-->
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Your first Kotlin program</h2>
				<em>Let's write some code!</em>
			</section>
		</section>
	</div>
</div>

<script src="./dist/reveal.js"></script>
<script src="./plugin/notes/notes.js"></script>
<script src="./plugin/markdown/markdown.js"></script>
<script src="./plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	})
	Reveal.configure({ showNotes: false })
</script>
</body>
</html>
