<!doctype html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

	<title>reveal.js</title>

	<link rel="stylesheet" href="dist/reset.css">
	<link rel="stylesheet" href="dist/reveal.css">
	<link rel="stylesheet" href="dist/theme/kotlin.css">

	<!-- Theme used for syntax highlighted code -->
	<link rel="stylesheet" href="plugin/highlight/vs.css">
</head>
<body>
<div class="reveal">
	<div class="slides">
		<section data-background-gradient="var(--kotlin-gradient)">
			<i>Week 1 | Lesson 4</i>
			<h1>Testing</h1>
			<em>Dependency Management, Logging, Debugging, Documentation</em><br/>
			<em>Testing fundamentals, Levels of testing, JUnit</em><br />
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Dependency Management</h2>
			</section>
			<section>
				<h3>Dependency Management in Java</h3>
				<div class="summary">
					Kotlin (JDK) comes with a set of libraries that allow us to do some basic development tasks.
					However, kotlin programmes often require more.
				</div>
				<div class="content">
					<p>
						As with any modern language, you can extend your code by using libraries, in Java, they are called
						dependencies.
					</p>
					<p>
						You could manage your dependencies manually, by adding their <strong>jar</strong> files to the project.
						Or you can use a tool to help you do that.
					</p>
					<p>
						There are two major tools for project and dependency management:
					<ul>
						<li><a href="https://maven.apache.org/">Maven</a></li>
						<li><a href="https://gradle.org/">Gradle</a></li>
					</ul>
					</p>
				</div>
			</section>
			<section>
				<h3>Dependency Management in Java/Kotlin</h3>
				<div class="summary">
					Besides managing dependencies, these tools also take care of setting up your <strong>project</strong>,
					<strong>modules</strong>, <strong>plugins</strong> and more.
				</div>
				<div class="content">
					<ol>
						<li>Java version management</li>
						<li>
							Dependency and version management (in scope)
							<ul>
								<li>development, test, runtime</li>
							</ul>
						</li>
						<li>Project structure</li>
						<li>
							Task configurations
							<ul>
								<li>build, publishing, testing</li>
								<li>documentation, code generation, data migrations</li>
							</ul>
						</li>
						<li>
							Plugins
							<ul>
								<li>developer tools, code quality, ...</li>
							</ul>
						</li>
					</ol>
					<p>
						Our project is using <a href="https://gradle.org/">Gradle</a>.
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Logging</h2>
			</section>
			<section>
				<h3>Logging</h3>
				<div class="summary">
					Logging is an important aspect of software quality.
					It allows us to monitor the behavior of the software while it is running in real world conditions,
					and to diagnose possible problems.
				</div>
				<div class="content">
					<p>
						Several login frameworks are available in Java, such as <strong>Log4j</strong>, <strong>Logback</strong> and <strong>java.common.logging</strong>.
					</p>
					<p>
						One of the popular Kotlin-specific logging frameworks is <strong>Kotlin-logging</strong>.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							import mu.KLogging

							object TemperatureConverter: KLogging() {

								fun toCelsius(fahrenheit: Double): Double {
									logger.info("Converting $fahrenheit Fahrenheit to Celsius")
									return (fahrenheit - 32) * 5 / 9
								}

								fun toFahrenheit(celsius: Double): Double {
									logger.info("Converting $celsius Celsius to Fahrenheit")
									return celsius * 9 / 5 + 32
								}

							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Logging Levels</h3>
				<div class="summary">
					Each logging framework has a set of logging levels that can be used to control the amount of information that is logged.
				</div>
				<div class="content">
					<p>
						There are several logging levels, such as <strong>TRACE</strong>, <strong>DEBUG</strong>, <strong>INFO</strong>, <strong>WARN</strong>, <strong>ERROR</strong> and <strong>FATAL</strong>.
					</p>
					<p>
						By setting the logging level, you can control the amount of information that is logged.
						For example, if you set the logging level to <strong>INFO</strong>, only messages with level <strong>INFO</strong> and higher will be logged.
					</p>
				</div>
			</section>
			<section>
				<h3>Exercise</h3>
				<div class="summary">
					Setup logging for your project.
				</div>
				<div class="content">
					<p>
						Add a Gradle dependency for <strong>Kotlin-logging</strong> and use it in your project by adding
						the following to the <strong>build.gradle.kts</strong> file dependencies section, so it might look like:
						So it might look like this:
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							dependencies {
								implementation("org.slf4j:slf4j-api:2.0.7")
								implementation("ch.qos.logback:logback-classic:1.4.11")
								implementation("io.github.oshai:kotlin-logging-jvm:7.0.3")
								testImplementation(kotlin("test"))
							}
						</code>
					</pre>
					<p>
						In your code, you add a logger by adding <code class="inline">KotlinLogging.logger { }</code>
						and use it by calling<br />
						<code class="inline">logger.info { "info message" }</code>,<br />
						<code class="inline">logger.debug { "debug message" }</code>,<br />
						<code class="inline">logger.error { "error message" }</code>, <br />
						etc.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							import io.github.oshai.kotlinlogging.KotlinLogging

							private val logger = KotlinLogging.logger { }

							fun main() {
								logger.info { "Hello, World!" }
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Exercise</h3>
				<div class="summary">
					Configure logging levels and appenders.
				</div>
				<div class="content">
					<p>
						Include this file in your <strong>src/main/resources</strong> folder.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							&lt;?xml version="1.0" encoding="UTF-8"?&gt;
								&lt;configuration&gt;
									&lt;statusListener class="ch.qos.logback.core.status.OnConsoleStatusListener" /&gt;

									&lt;appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender"&gt;
										&lt;encoder&gt;
											&lt;pattern&gt;%d{HH:mm:ss} %highlight(%-5level) [%thread] %cyan(%logger{1}) - %msg%n&lt;/pattern&gt;
										&lt;/encoder&gt;
										&lt;filter class="ch.qos.logback.classic.filter.ThresholdFilter"&gt;
											&lt;level&gt;INFO&lt;/level&gt;
										&lt;/filter&gt;
									&lt;/appender&gt;
									&lt;root level="TRACE"&gt;
										&lt;appender-ref ref="STDOUT" /&gt;
									&lt;/root&gt;
									&lt;logger name="*" level="DEBUG"/&gt;
								&lt;/configuration&gt;
						</code>
					</pre>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Debugging</h2>
			</section>
			<section>
				<h3>Debugging</h3>
				<div class="summary">
					Debugging is the process of finding and resolving defects or problems within a computer program that prevent correct operation of computer software or a system.
				</div>
				<div class="content content-center content-100">
					<p>
						<strong>It is an essential skill of any software developer.</strong>
					</p>
					<p>
						Usually, an IDE (such as IntelliJ IDEA) will have a debugger built in,
						which will allow you to <strong>step</strong> through your code,
						<strong>inspect variables</strong> and <strong>evaluate expressions</strong>
						to see what the program is doing, while it is executing
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Documentation</h2>
			</section>
			<section>
				<h3>Java Documentation</h3>
				<div class="summary">
					Another important aspect of software quality is documentation.
				</div>
				<div class="content">
					In Java, we can use a tool called <strong>Javadoc</strong> to generate documentation from our code.
					<div class="row">
						<div class="column" style="font-size: 80%">
							<pre>
								<code data-trim data-noescape data-line-numbers class="hljs kotlin">
									object TemperatureConverter: KLogging() {

										/**
										 * Converts temperature value given in Fahrenheit to Celsius
										 *
										 * @param fahrenheit temperature value in Fahrenheit
										 * @return temperature value in Celsius
										 * @see [Fahrenheit](https://en.wikipedia.org/wiki/Fahrenheit)
										 * @see [Celsius](https://en.wikipedia.org/wiki/Celsius)
										 */
										fun toCelsius(fahrenheit: Double): Double {
											logger.info("Converting $fahrenheit Fahrenheit to Celsius")
											return (fahrenheit - 32) * 5 / 9
										}

										/**
										 * Converts temperature value given in Celsius to Fahrenheit
										 *
										 * @param celsius temperature value in Celsius
										 * @return temperature value in Fahrenheit
										 * @see [Fahrenheit](https://en.wikipedia.org/wiki/Fahrenheit)
										 * @see [Celsius](https://en.wikipedia.org/wiki/Celsius)
										 */
										fun toFahrenheit(celsius: Double): Double {
											logger.info("Converting $celsius Celsius to Fahrenheit")
											return celsius * 9 / 5 + 32
										}

									}
								</code>
							</pre>
						</div>
						<div class="column">
							<img src="./img/javadoc.png" alt="Javadoc">
						</div>

					</div>
					<p>
						For details, see <a href="https://www.oracle.com/technical-resources/articles/java/javadoc-tool.html">Javadoc Tool</a>
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Introduction to Software Testing</h2>
			</section>
			<section>
				<h3>What is Testing</h3>
				<div class="content">
					<ul>
						<li>Testing aims to determine the degree of alignment between reality and expectations.</li>
						<li>It helps measure quality but cannot directly influence it.</li>
						<li>It provides information to stakeholders.</li>
						<li>It is an ongoing activity, not a development phase.</li>
						<li>It is the responsibility of the entire team, not an isolated role.</li>
						<li>
							The goal of testing is to:
							<ul>
								<li>Verify that the product does what is expected of it.</li>
								<li>Provide information.</li>
								<li>Identify problems, not just bugs.</li>
								<li>Reduce risks.</li>
							</ul>
						</li>
						<li>The goal of testing is not to make decisions but to provide information to support decision-making (the tester is not the decision-maker).</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>What is Quality</h3>
				<div class="summary">
					<p>
						What is quality, and how does it relate to testing and the product?
					</p>
					<p>
						Is a product considered good quality if it contains no errors?
					</p>
				</div>
				<div class="content content-center content-100">
					<div class="fragment fade-in">
						<blockquote>
							A product is something someone desires because it satisfies their needs.
						</blockquote>
					</div>
					<div class="fragment fade-in">
						<p>
							We can view the quality of a product from two perspectives:
						</p>
					</div>
					<div class="fragment fade-in">
						<blockquote>
							<em><strong>What the product does</strong> = external quality.</em><br />
							&<br />
							<em><strong>How it does it</strong> = internal quality.</em>
						</blockquote>
					</div>
				</div>
			</section>
			<section>
				<h3>External and Internal Quality</h3>
				<div class="content">
					<div class="row">
						<div class="column">
							<strong>External Quality</strong><br />
							<ul>
								<li>Does the product fulfill user's needs?</li>
								<li>Does it operate in a way that is usable for the user?</li>
							</ul>
						</div>
						<div class="column">
							<strong>Internal Quality</strong><br />
							<ul>
								<li>Is the software well written?</li>
								<li>Is the code readable and understandable?</li>
								<li>Is the code designed well?</li>
								<li>Is the code testable? Is the test coverage sufficient?</li>
								<li>Is there sufficient documentation?</li>
								<li>Is there sufficient logging?</li>
							</ul>
						</div>
					</div>
				</div>
				<div class="content">
					While it is possible for product with relatively low internal quality to have high external quality,
					it is not surprising, that the two usually correlate. When software is testable, it is easier to extend and maintain,
					requiring both less skill and time, making it more resistant to <strong>regression</strong>.
					</p>
					<blockquote>
						<strong>Regression</strong> == in terms of testing, regression is a defect unintentionally introduced by a change into a previously working part of software.
					</blockquote>
				</div>
			</section>
			<section>
				<h3>7 principles of testing</h3>
				<div class="content content-center content-100">
					<ol>
						<li>Testing shows the presence of defects, not their absence</li>
						<li>Exhaustive testing is not possible</li>
						<li>Early testing saves time and money</li>
						<li>Defect have a tendency to cluster</li>
						<li>The Pesticide Paradox</li>
						<li>Testing is context dependent</li>
						<li>Absence of errors fallacy</li>
					</ol>
				</div>
			</section>
			<section>
				<h3>The Testing Pyramid</h3>
				<div class="content content-center">
					<img src="./img/testing_pyramid.png" />
				</div>
			</section>
			<section>
				<h3>The Cost of Defects</h3>
				<div class="content content-center">
					<img src="./img/cost_of_defects.png" >
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Types of testing</h2>
			</section>
			<section>
				<h3>Types of testing</h3>
				<div class="summary">
					Testing based on the internal knowledge of the system
				</div>
				<div class="content">
					<p>
						There are two types of testing based on the testers knowledge of the system internal structure/design/implementation.
					</p>
					<br />
					<p>
						<h4>Blackbox Testing</h4>
						Internal structure of the system is <strong>not known</strong> to the tester.
					</p>
					<p>
						<h4>Whitebox Testing</h4>
						Internal structure of the system is <strong> known</strong> to the tester.
					</p>
					<br />
					<p>
						<h4>Greybox Testing</h4>
						Sometimes, this term is used when the internal structure of the system is <strong>partially known</strong> to the tester.
					</p>
				</div>
			</section>
			<section>
				<h3>Types of testing</h3>
				<div class="summary">
					Testing based on code execution
				</div>
				<div class="content">
					<div class="row">
						<div class="column">
							<h4>Dynamic</h4>
							<ul>
								<li>The tested system code is executed during testing</li>
								<li>
									Dynamic testing can further be divided into
									<ul>
										<li>Functional</li>
										<li>Non-functional</li>
									</ul>
								</li>
							</ul>
						</div>
						<div class="column">
							<h4>Static</h4>
							<ul>
								<li>Code is not executed during testing</li>
								<li>Static analysis usually involves the use of tools</li>
								<li>Code review</li>
								<li>Document reviews - specifications, requirement lists, tests, etc</li>
								<li>Best practices</li>
							</ul>
						</div>
					</div>
				</div>
			</section>
			<section>
				<h3>Functional vs. Non-Functional Testing</h3>
				<div class="summary">
					We can also distinguish between functional and non-functional testing.
				</div>
				<div class="content">
					<p>
						<h4>Functional testing</h4>
						is testing of the functionality of the system, meaning testing of functions of the system as a real user would use it.
						<br />
						<br />
						During functional testing, system functions and features are exercised by providing appropriate inputs and verifying that the outputs are as expected.
					</p>
					<br />
					<p>
						<h4>Non-functional testing</h4>
						is testing of the non-functional aspects of the system.
						<br />
						<br />
						Some examples of non-functional testing include: <br />
						<em>Performance, Security, Usability, Interoperability, Compatibility, Compliance, etc.</em>
					</p>
				</div>
			</section>
		</section>

		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Test Case</h2>
			</section>
			<section>
				<h3>What is a Test Case</h3>
				<div class="summary">
					Test case is a sequence of pre-conditions, inputs, actions steps with expected results and post-conditions, developed based on test conditions.
				</div>
				<div class="content">
					<p>
						<h4>Test condition</h4>
						is a testable aspect of a component or system identified as a basis for testing.
						<br />
						<br />
						<em>In other words, some behavior we expect from the system.</em>
					</p>
					<br />
					<p>
						<h4>Test case</h4>
						is a sequence of pre-conditions, inputs, actions steps with expected results and post-conditions, developed based on test conditions.
						<br />
						<br />
						<em>In other words, test case = a scenario describing how to test a particular test condition.</em>
					</p>
				</div>
			</section>
			<section>
				<h4>Test Case</h4>
				<div class="content">
					<p>
						<strong>Test ID:</strong> 1234<br />
					</p>
					<p>
						<strong>Title:</strong> User is blocked after 3 failed login attempts<br />
					</p>
					<p>
						<strong>Pre-Conditios:</strong><br />
						User test.user@harbourspace.com exists and is not blocked.
					</p>
					<p>
						<strong>Test Steps:</strong><br />
					</p>
					<table>
						<thead>
						<tr>
							<td>#</td>
							<td>Step</td>
							<td>Expected Result</td>
						</thead>
						<tbody>
						<tr>
							<td>1.</td>
							<td>Open the login page</td>
							<td>Login page is shown</td>
						</tr>
						<tr>
							<td>2.</td>
							<td>Enter the username <em>test.user@harbourspace.com</em> and password <em>invalid</em></td>
							<td>User is not logged in, is informed of invalid credentials. Password field is nullified.</td>
						</tr>
						<tr>
							<td>3.</td>
							<td>Enter the password <em>invalid</em> again</td>
							<td>User is not logged in, is informed of invalid credentials. Password field is nullified.</td>
						</tr>
						<tr>
							<td>4.</td>
							<td>Enter the password <em>invalid</em> again</td>
							<td>User is not logged in, is informed that their account was locked.</td>
						</tr>
						</tbody>
					</table>
					<p>
						<strong>Expected Result:</strong><br />
						User is not logged in and their account is locked.
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Test design techniques</h2>
			</section>
			<section>
				<h3>Test design techniques</h3>
				<div class="summary">
					What are they and why should developers care?
				</div>
				<div class="content">
					<p>
						<span class="highlight">Test design techniques</span> are techniques used to design tests.
						<br />
						<br />
						They are used to ensure adequate <strong>test coverage</strong>, optimize the number of tests, maximize the effectiveness of tests and manage risks.
					</p>
					<br />
					<p>
						<span class="highlight">Test coverage</span>
						is a measure of the degree to which the source code of a program has been tested.
					</p>
					<p>
						It is usually expressed as a percentage of code that has been executed by the test suite.
						<br />
						Different metrics are used to measure test coverage, such as <em>function coverage, statement coverage, branch coverage, etc.</em>
					</p>
					<br />
					<blockquote>
						Remember that exhaustive testing is impossible!
					</blockquote>
				</div>
			</section>
			<section>
				<h3>Equivalence Partitioning</h3>
				<div class="summary">
					Equivalence partitioning is a technique used to reduce the number of test cases by dividing the input data of a software unit into partitions of equivalent data from which test cases can be derived.
				</div>
				<div class="content">
					<img src="./img/equivalence_boundary.png" />
					<p>
						In this example, there are 4 partitions of equivalent data.
						In theory, any test case from a partition should yield the same result.
					</p>
					<p>
						For example these sets of values belong to the same partitions:<br />
						<span style="color: red">-275.0</span>, <span style="color: green">-1.0</span>, <span style="color: green">10.0</span>, <span style="color: red">100.1</span><br />
						<span style="color: red">-280.0</span>, <span style="color: green">-100.0</span>, <span style="color: green">99.0</span>, <span style="color: red">101.0</span>
					</p>
				</div>
			</section>
			<section>
				<h3>Boundary Value Analysis</h3>
				<div class="summary">
					Boundary value analysis is a software testing technique similar to equivalence partitioning,
					but the tests are designed to look program behavior at boundary values.
				</div>
				<div class="content">
					<img src="./img/equivalence_boundary.png" />
					<p>
						There are 3 boundary values in this example: <strong>-273.15</strong>, <strong>0.0</strong> and <strong>100.0</strong>
					</p>
					<p>
						Equivalence partitioning and boundary value analysis are often used together.
					</p>
				</div>
			</section>
			<section>
				<h3>Decision Tables</h3>
				<div class="summary">
					Decision table testing is a testing technique in which test cases are designed to execute the combinations of inputs and/or stimuli (causes) shown in a decision table.
				</div>
				<div class="content">
					<table>
						<thead style="font-weight: bold; background-color: var(--kotlin-color-2)">
						<tr>
							<td>Conditions</td>
							<td>Test 1</td>
							<td>Test 2</td>
							<td>Test 3</td>
							<td>Test 4</td>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>User exists</td>
							<td>YES</td>
							<td>YES</td>
							<td>NO</td>
							<td>YES</td>
						</tr>
						<tr>
							<td>Password correct</td>
							<td>YES</td>
							<td>NO</td>
							<td>-</td>
							<td>YES</td>
						</tr>
						<tr>
							<td>User blocked</td>
							<td>NO</td>
							<td>NO</td>
							<td>NO</td>
							<td>YES</td>
						</tr>
						</tbody>
						<thead style="font-weight: bold; background-color: lightgrey">
						<tr>
							<td>Actions</td>
							<td>Test 1</td>
							<td>Test 2</td>
							<td>Test 3</td>
							<td>Test 4</td>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td>Allow access</td>
							<td>YES</td>
							<td>NO</td>
							<td>NO</td>
							<td>NO</td>
						</tr>
						<tr>
							<td>Block user</td>
							<td>NO</td>
							<td>YES</td>
							<td>-</td>
							<td>-</td>
						</tr>
						</tbody>
					</table>
				</div>
			</section>
			<section>
				<h3>State Transition Analysis</h3>
				<div class="summary">
					State transition testing is a testing technique in which outputs are triggered by changes to the input conditions or changes to state of the system.
				</div>
				<div class="content">
					<img src="./img/state_transition.png" />
				</div>
			</section>
			<section>
				<h3>Orthogonal array testing</h3>
				<div class="summary">
					Orthogonal array testing statistical method of test design aimed to test interactions of multiple variables,
					their combinations and interactions, while minimizing the number of test cases.
				</div>
				<div class="content">
					<p>
						<h4>Example:</h4>
						Assume we have a system that takes 3 parameters: color, shape and size, each parameter has 2 values.
						<br />
						<br />
						To test all possible combinations of these parameters, we would need 8 test cases.
						<br />
						<br />
						With orthogonal array testing, we can achieve the same coverage with only 4 test cases.
					</p>
					<table>
						<thead>
						<tr style="font-weight: bold">
							<td style="font-weight: bold"></td>
							<td>Color</td>
							<td>Shape</td>
							<td>Size</td>
						</tr>
						</thead>
						<tbody>
						<tr>
							<td style="font-weight: bold">Test 1</td>
							<td>red</td>
							<td>square</td>
							<td>small</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Test 2</td>
							<td>red</td>
							<td>circle</td>
							<td>large</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Test 3</td>
							<td>green</td>
							<td>square</td>
							<td>large</td>
						</tr>
						<tr>
							<td style="font-weight: bold">Test 4</td>
							<td>green</td>
							<td>circle</td>
							<td>small</td>
						</tr>
						</tbody>
					</table>
					<p>
						This is an orthogonal array of 2 factors with 2 levels each - L4(2^3).
					</p>
				</div>
			</section>
			<section>
				<h3>All-Pairs Testing</h3>
				<div class="summary">
					All-pairs testing is a combinatorial software testing method that, for each pair of input parameters to a system (typically, a software algorithm), tests all possible discrete combinations of those parameters.
				</div>
				<div class="content">
					<blockquote>
						It is based on the observation that most faults are caused by interactions of at most two factors.
					</blockquote>
					<p>
						This testing technique is rarely implemented "by hand", but usually with the help of specialized tools.
					</p>
					<p>
						There are techniques that extend all-pairs testing to more than two factors, such as all-tuples testing, but these techniques are not widely used, because they generate very large number of test cases with insignificant added benefit.
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Unit Testing</h2>
			</section>
			<section>
				<h3>Unit Testing</h3>
				<div class="summary">
					The purpose of unit testing is to verify individual units of the code base work as intended by the author.
					It is an essential tool in maintaining <strong>internal quality</strong> of a software.
				</div>
				<div class="content">
					<p>
						<h4>Unit</h4>
						Unit is he smallest testable parts of the software, such as individual method, function or objects.
					</p>
					<br />
					<p>
						Another important role of unit testing is documentation. By writing unit tests, we document the behavior
						we intended, so that when we, or someone else wants to make changes in the software, they will understand
						how the software was supposed to work.
					</p>
				</div>
			</section>
			<section>
				<h3>Assertion</h3>
				<div class="summary">
					<strong>Assertion</strong> is a term used form mechanism of verifying if test expected outcomes match actual outcomes.
				</div>
				<div class="content">
<!--					<p>-->
<!--						Assertion itself is usually a function (method) that we call in our tests which evaluates actual value with expected value.-->
<!--						<br />-->
<!--						Based on result of this evaluation, the assertion ends in one of two states:-->
<!--						<br />-->
<!--						<br />-->
<!--						<em style="color: green; font-weight: bold">PASSED</em> or <em style="color: red; font-weight: bold">FAILED</em>-->
<!--					</p>-->
					<ul>
						<li>Assertion itself is usually a function (method) that we call in our tests which evaluates actual value with expected value.</li>
						<li>
							Based on result of this evaluation, the assertion ends in one of two states:
							<br />
							<br />
							<div style="text-align: center; font-size: 110%">
								<em style="color: green; font-weight: bold">PASSED</em> or <em style="color: red; font-weight: bold">FAILED</em>
							</div>
							<br />
							<br />
						</li>
						<li>Test may contain any number of assertions, anywhere within the test.</li>
						<li>When a test is run, and no assertion fails, the test is marked as passed.</li>
						<li>When a test is run, and any assertion fails, the test is marked as failed.</li>
						<li>
							Generally, when assertion fails, test is ended immediately.<br />
							Any code following the assertion is not executed.
						</li>
					</ul>
				</div>
			</section>
			<section>
				<h3>Test Driven Development</h3>
				<div class="summary">
					You may encounter the term <strong>Test Driven Development</strong> (TDD).
					Know that, although the term suggest it might be testing technique, it really is not.
					Rather it is a software design technique.
				</div>
				<div class="content">
					<ol>
						<li>In TDD, you write a tests first, they will initially be failing.</li>
						<li>Then you start implement the functionality.</li>
						<li>When all the tests finally pass, your implementation is complete.</li>
					</ol>
					<p>
						The reason TDD is development technique and not a test technique is because by writing tests
						first, you are making code testable by design. Well-testable code usually directly correlates with
						code quality and therefore overall software quality.
					</p>
				</div>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Integration Testing</h2>
			</section>
			<section>
				<h3>Integration Testing</h3>
				<div class="summary">
					Integration testing is a level of software testing, which aims to test the integration of different units or components of the system.
				</div>
				<div class="content">
					<p>Integration testing can be ...</p>
					<ul>
						<li>Integration of different modules, classes, or services within the software.</li>
						<li>
							Testing of the integration of other systems, such as ...
							<ul>
								<li>Operating System functions and services</li>
								<li>Database, file systems, data sources</li>
								<li>External services, APIs, message queues, cloud services</li>
							</ul>
						</li>
					</ul>
					<p>
						Integration tests are typically more costly to run than unit tests,
						because they require more resources and are usually slower.
						They may also be less reliable.
					</p>
					<p>
						On the other hand, they provide more information about the system as a whole, and may uncover problems that are not visible at the unit level.
					</p>
				</div>
			</section>
		</section>

		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>JUnit</h2>
			</section>
			<section>
				<h3>JUnit</h3>
				<div class="summary">
					<strong>JUnit</strong> of the most commonly used testing frameworks for Java and also for Kotlin.
				</div>
				<div class="content">
					<p>
						Unit testing framework is a set of tools that provides features to:
					</p>
					<ul>
						<li>Write test cases</li>
						<li>Executed test cases</li>
						<li>Evaluate test results</li>
					</ul>
					<p>
						There are other of unit testing frameworks available in Kotlin, such as <strong>Kotest</strong><br />
					</p>
					<p>
						The concepts that we will learn with JUnit generally apply to all unit testing frameworks.
					</p>
				</div>
			</section>

			<section>
				<h3>JUnit Test</h3>
				<div class="content">
					<ul>
						<li>JUnit test, generally, is a class that contains one or more test methods.</li>
						<li>Each test method is a method annotated with <code class="inline">@Test</code> annotation.</li>
						<li>
							Besides being annotated with <code class="inline">@Test</code> annotation, in order for a method considered a test,
							<strong>it must contain at least one assertion</strong>.
						</li>
						<li>By convention, test classes are usually suffixed with <code class="inline">Test</code></li>
						<li>
							While program sources are plces in <code class="inline">/src/main/kotlin</code> directory,
							test sources are conventionally placed in <code class="inline">/src/test/kotlin</code> directory.
						</li>
						<li>
							It is important, that the test code is as readable as possible.
							Therefore, good naming conventions are essential.
						</li>
					</ul>
				</div>
			</section>

			<section>
				<h3>JUnit Test</h3>
				<div class="summary">
					JUnit tests are just regular Java classes, where methods annotated with <code class="inline">@Test</code>
					are treated little different from regular methods by the testing framework.
				</div>
				<div class="content">
					<p>
						Assertions are just regular method calls, where the testing framework evaluates the result of the assertion.
						In JUnit, we can use <code class="inline">Assertions</code> class to make assertions.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							package lesson03

							import org.junit.jupiter.api.Assertions
							import org.junit.jupiter.api.DisplayName
							import org.junit.jupiter.api.Test

							// By convention the name of the test class should be the name of the class under test + "Test"
							class TemperatureConverterTest {

								@Test
								@DisplayName("should convert Celsius to Fahrenheit - 0C = 32F")
								fun testConvertCelsiusToFahrenheit() {
									Assertions.assertEquals(32.0, TemperatureConverter.toFahrenheit(0.0));
								}

								// different style of test name
								@Test
								fun `should convert Fahrenheit to Celsius - 32F = 0C`() {
									Assertions.assertEquals(0.0, TemperatureConverter.toCelsius(32.0));
								}
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Clean tests <=> clean code</h3>
				<div class="content content-center content-100">
					<h4>Writing testable code matters!</h4>
					I can say through my own experience, that the more testable the code unit is, the better it usually is.
					This is because testability is an indicator of good design and therefore indicator of <strong>internal quality</strong>.
					<br />
					<br />
					<h4>Writing clean tests matters!</h4>
					During real-world development, you will often be dealing with code you didn't write yourself.
					You will come to appreciate well written tests, because they will help you understand the code you are working with.
					<br />
					<br />
					Same goes also in the other direction, your colleagues will appreciate good tests you write, because they will help them understand your code.
				</div>
			</section>
			<section>
				<h3>Good tests</h3>
				<div class="summary">Writing reliable and maintainable tests</div>
				<div class="content">
					<p>
						The value of tests is that they give us feedback during development.
						There are few rules that help us make sure that the feedback we get from tests is accurate and reliable.
					</p>
					<h4>Test should be:</h4>
					<ul>
						<li><strong>Deterministic</strong> - each test run should yield the same result.</li>
						<li><strong>Easy to understand</strong> - this will help with interpreting results and maintenance.</li>
						<li><strong>Fast</strong> - we want fast feedback loop.</li>
						<li><strong>Independent</strong> - each test should be able to run in isolation and in any order.</li>
						<li><strong>Repeatable</strong> - each test should be able to run multiple times.</li>
						<li><strong>Focused</strong> - each test should focus on testing one thing only.</li>
					</ul>
				</div>
			</section>
			<section>
				<h4>Descriptive tests</h4>
				<div class="summary">
					One of the ways you can make your test code easier to understand is using descriptive names and well-designed assertions.
				</div>
				<div class="content">
					<p>
						With <strong>JUnit</strong>, we can use <code class="inline">@DisplayName</code> annotation to give our tests descriptive name.
						Notice that the test names express state of the SUT, but also what we expect from the SUT.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							@Test
							@DisplayName("should convert Celsius to Fahrenheit - 0C = 32F")
							fun testConvertCelsiusToFahrenheit() {
								Assertions.assertEquals(32.0, TemperatureConverter.toFahrenheit(0.0));
							}
						</code>
					</pre>
					<p>
						Another option is to use Kotlin's string templates to make test names more descriptive.
					</p>
					<pre>
						<code data-trim data-noescape class="hljs kotlin">
							@Test
							fun `should convert Fahrenheit to Celsius - 32F = 0C`() {
								Assertions.assertEquals(0.0, TemperatureConverter.toCelsius(32.0));
							}
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h4>Descriptive assertions</h4>
				<div class="summary">
					Another important aspect of testing is understanding test results.
				</div>
				<div class="content">
					<p>
						To make understanding test results easier, we can use <code class="inline">Assertions</code> class methods in a way that when they fail, the output is as descriptive of the problem as possible.
					</p>
					<p>
						For example, these two assertions would both work, the first one provides much clearer information
						when it fails.
					</p>
					<strong>Example 1</strong>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@Test
							fun testConvertCelsiusToFahrenheit() {
								Assertions.assertEquals(32.1, TemperatureConverter.toFahrenheit(0.0));
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs text">
							Expected :32.1
							Actual   :32.0
						</code>
					</pre>
					<strong>Example 2</strong>
					<pre>
						<code data-trim data-noescape data-line-numbers class="hljs kotlin">
							@Test
							fun testConvertCelsiusToFahrenheit() {
								Assertions.assertTrue(32.1 == TemperatureConverter.toFahrenheit(0.0));
							}
						</code>
					</pre>
					<pre>
						<code data-trim data-noescape class="hljs text">
							Expected :true
							Actual   :false
						</code>
					</pre>
				</div>
			</section>
			<section>
				<h3>Test Lifecycle</h3>
				<div class="summary">
					Test lifecycle is the sequence of events that happen during the execution of a test.
				</div>
				<div class="content">
					<p>
						Several annotations can be used to control the test lifecycle.
						These annotations are: <br />
						<code class="inline">@BeforeAll</code>, <code class="inline">@BeforeEach</code>, <code class="inline">@AfterEach</code> and <code class="inline">@AfterAll</code>
					</p>
					<p>
						<strong>
							When JUnit test case is started:
						</strong>
					</p>
					<ol>
						<li>JUnit Test class gets loaded and scanned for <code class="inline">@Test</code> annotation marking individual test cases</li>
						<li><code class="inline">@BeforeAll</code> - is run before all <code class="inline">@Test</code> methods</li>
						<li><code class="inline">@BeforeEach</code> - is run before each <code class="inline">@Test</code> methods</li>
						<li><code class="inline">@AfterEach</code> - is run after each <code class="inline">@Test</code> methods</li>
						<li><code class="inline">@AfterAll</code> - is run after all <code class="inline">@Test</code> methods</li>
					</ol>
					<p>
						Note that <code class="inline">@Test</code> methods may run in any order, or may run in parallel.
					</p>
				</div>
			</section>
			<section>
				<h3>JUnit Test Lifecycle</h3>
				<pre>
					<code data-trim data-noescape data-line-numbers class="hljs kotlin">
						package lesson03

						import org.junit.jupiter.api.AfterAll
						import org.junit.jupiter.api.AfterEach
						import org.junit.jupiter.api.Assertions
						import org.junit.jupiter.api.BeforeAll
						import org.junit.jupiter.api.BeforeEach
						import org.junit.jupiter.api.DisplayName
						import org.junit.jupiter.api.Test

						class TemperatureConverterTest {

							@BeforeEach
							fun beforeEach() {
								println("This runs before each test");
							}

							@AfterEach
							fun afterEach() {
								println("This runs after each test");
							}

							@Test
							@DisplayName("should convert Celsius to Fahrenheit - 0C = 32F")
							fun testConvertCelsiusToFahrenheit() {
								Assertions.assertEquals(32.0, TemperatureConverter.toFahrenheit(0.0));
							}

							// different style of test name
							@Test
							fun `should convert Fahrenheit to Celsius - 32F = 0C`() {
								Assertions.assertEquals(0.0, TemperatureConverter.toCelsius(32.0));
							}

							companion object {

								@BeforeAll
								@JvmStatic
								fun setUp() {
									println("This runs once before all tests");
								}

								@AfterAll
								@JvmStatic
								fun tearDown() {
									println("This runs once after all tests");
								}
							}
						}
					</code>
				</pre>
			</section>
		</section>
		<section>
			<section data-background-gradient="var(--kotlin-gradient)">
				<h2>Practice</h2>
			</section>
		</section>
	</div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
	// More info about initialization & config:
	// - https://revealjs.com/initialization/
	// - https://revealjs.com/config/
	Reveal.initialize({
		hash: true,

		// Learn about plugins: https://revealjs.com/plugins/
		plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
	});
</script>
</body>
</html>
